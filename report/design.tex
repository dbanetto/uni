\chapter{Design}\label{C:design}
% The aim here is to identify the key trade-offs in any design work you have undertaken.
% When solving a complex problem, there are normally many different
% approaches one can take — each with its own advantages and disadvantages.
% It is expected that students will have initially considered a range of different solutions,
% and will then have narrowed these down. The reasons why a particular approach was
% discounted should be documented here.
%
% Remember:
% Appropriate design notation (e.g. UML diagrams) can be very helpful in conveying different aspects of a design.
% It is vital that your design not be carried out in a vacuum.
% Your design should be motivated very clearly by your goals and specifications.
% Make sure that it is clear why you took the decisions that you did.
% Do not give the impression that you settled on a design because it “felt right”
% or that you tinkered around until you found something that worked. 

% intro to problem, what is the design space for this issue
%

This chapter will discuss the consideration taken to design the implementation
of this project.
These considerations are guided by improving or retaining the same level of 
usability of the Whiley Compiler for a Whiley developer and a maintainer of the
compiler fixing or updating the modified compiler. 
It will also discuss the internal design decisions of
where to place the loop invariants generators in the
current architecture of the Whiley Compiler.
This includes where the generated loop invariants are found and
how they are inserted into the program.
The final design decision discussed is how the multiple generators are managed.


\section{Considerations}
% These are designs for the project and the changes and impacts on the Whiley
% Language and compiler

Throughout the design of the overall architecture and each individual loop invariant
generator some design considerations were kept in mind.
\begin{itemize}
    \item{Backward creditability with non-loop invariant generated code.}
    \item{Not to hamper the ability to inspect and debug generated code.}
    \item{Avoid creating new local variables when generating code.}
    \item{Ensure the user can control the feature.}
    \item{Not all of the generated loop invariants will be useful.}
\end{itemize}

\subsection{Backwards Compatibility}
% pre-existing code should not fail because of the generated invariants
% code that compiles without the flag should still compile with the flag
% restricts loop invariants to be precise  and strict to avoid "wrong"

A design consideration for this project was that existing code that compiled
and verify without the loop invariant generator should still compile and verify
with it.
This consideration limits the generated loop invariants from creating
invariants that would not be supported by the program during verification.
Figure~\ref{lst:backwards-compat} shows an example of a potential loop
invariant generator that would cause previously working code to fail.
%% TODO: explain the example
When this occurs it is considered a bug and evidence that the implementation or
the design of the generated loop invariant is unsound and should be reviewed.

\begin{figure}[ht]
\begin{lstlisting}
// TODO: Make an example of where a generated invariant would make the code
// fail
\end{lstlisting}
    \label{lst:backwards-compat}
    \caption{Example of a Whiley program with generated loop invariants that will
    make it fail to verify.}
\end{figure}

However, this consideration is not reflexive.
This implies that it does not ensure that a program that verifies with
generated loop invariants must still verify without them.
This design issue is considered as it is important that a user could
switch to using the generated loop invariants without suddenly having
their program failing to verify.


\subsection{Inspection and Debugging}
% Allow debugging / reviewing  of generated code
% achieved by emitting compiler messages about what, where and why they are
% generated

The ability to be able to inspect the generated code is an important feature to
design into the solution.
This could come in the form of compiler message describing what, where and why
the loop invariants were generated or by writing the modified program back
to disk as source code.
This allows a user to be able to inspect and review the generated loop invariants for
debugging of their code or in the process of debugging a generator.
The compromise made by this feature is that it requires coupling to other
subsystems to report back these changes.
For example to emit a compiler message appropriately it would need
to couple with the logging sub-system to enforce common log modes such as
\code{DEBUG} and \code{VERBOSE}.

\subsection{Creating Variables}
% Whiley does not have the notion of ghost variables
%  * possible name collisions
%  * This is to be avoided
%
%  Does force the programmer to make ghost variables or make copies
%  that make sense if they were making the invariants themselves vs generated

The design consideration of creating variables that only used in specifications
were made for each generator.
Whiley does not have a notion of ghost variables, variables only used for
specifications, this forces the use of additional local variables instead \cite{whiley-origin}.
Figure~\ref{lst:vars} shows a common code example when the additional local
variables are used, in this case \code{items} variable is used to compare
against the previous value.
This forces a loop generator to either create their own ghost variables or
attempt to identify another local variable in the program that will act as the
same.
To generate the local variable the type of the copied variable is needed to be
known to mimic and a new statement directly before the loop is needed to be
added.
For example figure~\ref{lst:vars} would replace the \code{modified} variable
with \code{items} and the generated code will have an assignment just before
the while loop.
The issue of creating local variables is that it could add a runtime cost by
adding an additional copy of a potentially large data structure
and holding it in memory without being used.
The alternative to this is to restrict the loop invariant generators to check
for other variables that can work as pseudo-ghost variables.
This pattern is common in Whiley code as the lack of ghost variables require
the style of code in figure~\ref{lst:vars} to verify. 
This resolves the issue of hidden local variables from the programmer
and gives them control over how they are handled.
The trade-off of not having a hidden runtime cost with restricted generators
is the most beneficial for the end-user as existing code will also benefit
and for more complex invariants the ghost variables are still required.

\begin{figure}[ht]
\begin{lstlisting}
function add\_one(int[] items) -> int[]:
    i = 0
    modified = items
    //
    while i < |items|
        where all { k in 0..i | modified[i] == items[i] + 1 }
        where |modified| == |items|:
        modified = items[i] + 1
        i = i + 1
    //
    return modified
\end{lstlisting}
    \label{lst:vars}
    \caption{Example of Whiley program with \code{modified} .}
\end{figure}

\subsection{Usability}
% COMPILER FLAGS
% How easy it is to control the functionality 
% Error messages
% No goal on time impact
% choice to not repeat compilation and verification



\subsection{Essential Invariants}
% It is known that all invariants genereated will not be useful to proving the post-condition
% (due to P-C has no input generated inv)
% It is OK to have the minimal set of invariants
% to test if it is essential requires repetitive verifications, infringes on
% impact on compile time

During the design of this solution it is known that not all generated
invariants will be essential invariants.
This implies that not all of the generated loop invariants will be useful
in proving the post-condition of the loop's function.
If only the essential invariants where generated the solution would need
to determine what is essential either by increasing the complexity of the
generators by inferring the invariants from the post-condition or by 
attempting to minimize the generated loop invariants by testing combinations 
of invariants.
The trade-off of this decision is that at the cost of having some non-essential
invariants that the complexity of code and time generating loop invariants is
greatly reduced.

% Biggest design decision  was at what level are the invariants going to be inferred
% then where are they going to be generated
\section{Approaches to Loop Invariant Generation}

The principle design decision of this project was at
what point in the Whiley Compiler pipeline
to generate the loop invariants.
There are three candidate stages in the Whiley Compiler
that the input program will go through in the process of
being verified, the list is not necessarily in order of occurrence:

\begin{itemize}
    \item{Whiley Intermediate Language}
    \item{Whiley Assertion Language}
    \item{Whiley's Abstract Syntax Tree}
\end{itemize}

Each of these stages have different representations of the Whiley program and
associated information about the program itself.
In the resulting solution the design approach taken was to build upon 
Whiley's abstract syntax tree.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    %TODO: UML diagram
    PUT A UML DIAGRAM OF THE AST
\end{minipage}
    \label{lst:design-wyil}
    \caption{Example of a Whiley snippet and UML of its AST}
\end{figure}

\subsection{Whiley Intermediate Language (WyIL)}
% possible method to create tool on WyIL
% What could be achieve with this
%  * is designed to be a binary version of the code
%  * WyIL goal is to make intermediate language between ALL targets of Whiley
%  * AST converted into loosely connected values via integers
%  * less information readily available 

The Whiley Intermediate Language is a binary representation of a Whiley program
that can be easily transformed into other targets such as languages or
instruction sets \cite{wyil}.
It is a register based language with no nested expressions 
that also includes blocks to group together statements such as the body of a loop.
This allows the language to keep a majority of its structure with the 
exception of local variables and intermediate values becoming indistinguishable 
without analysis.

The structure of internal API to query and modify WyIL code impedes a
generator's ability to match it against a loop pattern.
This is from the internal structure of a statement in WyIL where each
statement is loosely defined with op codes and blocks.
By generating the loop invariants as additional byte code the ability to
inspect the result and debug them are hampered relative to operating on the
AST.  This is because the ability to decompile from WyIL to Whiley could
be impeded which prevents the user from being able to inspect the generated
code. 
WyIL can also be decompiled to a representation similar to assembly, see
figure~\ref{lst:design-wyil} for an example of Whiley code compared to its
intermediate language equivalent.
This example shows the amount of information available about the variables
in the program and their usage in the loop.
This approach was not selected due to the disconnect between loop patterns
in the programmer source code to their representation in WyIL.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyIL Code},frame=tlrb,numbers=none]{Name}
const %1 = 0
loop modifies %1
    invariant :
        const %2 = 0
        ifge %1, %2
        goto lab_0
        fail
    .lab_0
        return
    ifge %1, %0
    goto lab_1
    add %1 = %1, %0
.lab_1
return %1
\end{lstlisting}
\end{minipage}
    \label{lst:design-wyil}
    \caption{Example of simple Whiley snippet as WyIL}
\end{figure}

\subsection{Whiley Assertion Language (WyAL)}
%% WyAL
% what it is
% * changes would be more dramatic
% * Does not have the same level of control
% * hosted inside the theorem prover

\cite{wyal}


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyAL Code},frame=tlrb,numbers=none]{Name}

\end{lstlisting}
\end{minipage}
    \label{lst:design-wyil}
    \caption{Example of simple Whiley snippet as WyAL}
\end{figure}

\subsection{Whiley Abstract Syntax Tree}
% Whiley files
% * Closest to programmer code
% * most information in the most related form
% * 


The Whiley abstract syntax tree (AST) is the closest representation to
the source code.
This also includes the most information available, which includes detailed
types, variable names and expression trees \cite{whiley-origin}.
The AST is broken into three types of: top level declarations of types,
methods and functions ; statements blocks for individual statements
such as assignments or structures such as if statements; and, expressions
that include the usage of variables, function calls and constants.
There is some overlap between statements and expressions in the AST,
such as function calls are both statements and expressions given that they
return a value.
This gives the invariant generator to be able to identify loop patterns in the
structure.

However, the amount of information comes as at a cost of being able to parse
it and discover relevant information.
The structure of internal API of the Whiley AST forces a recursive decent
approach, much like the other internal languages in the compiler.
However, the AST is the richest in terms of number of types of nodes
in the AST needed to be supported to parse properly with
statement trees, expression trees and top-level declarations of methods and
types.
The cost of supporting all of these different nodes in the AST is
repeated code handling traversal and needing to handle a large range
of cases to parse a statement.
These costs are acceptable since it allows for generators to be
the most expressive and enable other design constraints of
debugging and inspection.

\section{Architecture of Loop Invariant Generators}
% ALL ONE BLOB! vs strategy + a common set of information
% Explain how each generator is distinct code
% UML of strategy pattern
% the utility package

\subsection{Monolithic}
% What would a monolithic look like
% how would it impact metrics such as maintainability
% how would it impact performance

\subsection{Strategy Pattern}
% What would a monolithic look like
% how would it impact metrics such as maintainability
% how would it impact performance
