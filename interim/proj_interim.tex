\documentclass[11pt, a4paper, twoside, openright]{report}

\usepackage{float} % lets you have non-floating floats

\usepackage{listings}
\usepackage[usenames, dvipsnames]{color}
\usepackage{url} % for typesetting urls
\usepackage{mathtools}
\usepackage{pdfpages} % for including PDF's into the document
\usepackage[parfill]{parskip}
\usepackage{hyperref}

%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

\definecolor{grey}{rgb}{0.95,0.95,0.95}

\lstset{%
    backgroundcolor=\color{grey},
    frame=single,
    numbers=left
}

%% These are standard LaTeX definitions for the document
%%
\title{Generating simple loop invariants for Whiley}
\author{David Barnett}

%% This file can be used for creating a wide range of reports
%%  across various Schools
%%
%% Set up some things, mostly for the front page, for your specific document
%
% Current options are:
% [ecs|msor|sms]          Which school you are in.
%                         (msor option retained for reproducing old data)
% [bschonscomp|mcompsci]  Which degree you are doing
%                          You can also specify any other degree by name
%                          (see below)
% [font|image]            Use a font or an image for the VUW logo
%                          The font option will only work on ECS systems
%
\usepackage[image,ecs]{vuwproject}

\supervisors{Lindsay Groves}
\otherdegree{Bachelor of Engineering with Honours in Software Engineering}

% Comment this out if you want the date printed.
\date{}
\newcommand{\code}[1]{\texttt{#1}}
% \newcommand{\todo}[1]{\huge{\underline{\textbf{\textcolor{RubineRed}{TODO}}: \textcolor{ForestGreen}{#1}}}\normalsize }
\newcommand{\sst}{\textsuperscript{st}}
\newcommand{\snd}{\textsuperscript{nd}}
\newcommand{\sth}{\textsuperscript{th}}

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
    This interim report presents the current progress of the ``Generating simple loop
    invariants in Whiley'' project so far.
    The objective of this project is to generate simple loop invariants in
    the Whiley language to relieve some proof obligation from the user.
    Currently two loop invariants can be generated from source code with plans
    to add more or expanding the use cases of existing generators.
    This will be evaluated by studying the impact of the generated invariants
    on a collection of Whiley code.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{1. Introduction}
% This should briefly outline the project and if necessary
% reevaluate the original plan in light of what has been learned in the interim.  In
% particular, any significant deviations in the problem being addressed, or the solution
% being developed should be clearly highlighted and justified. (1 pages)
%% TODO: Also have the proposal as an appendix

% outline
Whiley is a programming language that can be used for formal software
verification \cite{whiley-origin}.
One aspect of formal software verification is providing loop
invariants.
Some loop invariants are common for verified software and become a burden to
provide the same loop invariant repetitively.
The primary goal of this project is to relieve some proof obligations from a
Whiley programmer by automatically providing some simple loop invariants.
Instead the loop invariants are generated by the Whiley Compiler itself.
This project does not attempt to generate loop invariants generally, as it is
known to be uncomputable, but generates invariants for specific common cases.

\subsection*{1.1 Motivation}

% Why
The motivation of this project is to make Whiley more usable in practise.
Loop invariants are a common pain point for users of formally verified
languages.
There are simple loop invariants that are repetitive and are a chore to
always provide them.
These include the simple index into an array and other invariants that
are obvious to the reader on inspection but still are required to be
provided by the programmer.
With this project some of this pain is alleviated.

% \todo{changes since proposal}
% Changes since proposal

\subsection*{1.2 Solution}

% brief overview of solution
The solution this project provides to this problem is an extension to
the Whiley Compiler to generate simple loop invariants.
This includes the identification of simple loop invariants and being able
to generate a loop invariant from the source code of a Whiley program.
Since the Whiley Compiler is an open source project this project will be
hosted in a fork of compiler.

% 'simple'
The definition of a simple loop invariants for this project is an invariant that is
obvious at inspection that an invariant both exists and holds.
An example would be that while iterating through an array the index
will not go out of bounds of the array, such as figure~\ref{lst:whiley-ex-1}.
The purpose of having a definition of an simple invariant is to prevent
possible confusion when what looks to be unproven code is verified and to point
the scope of the project away from being too general, such as supporting
a rare scenarios such as indexing an array with a polynomial formula.
This leaves the more interesting invariants for the user to define.

\begin{figure}[ht]
\begin{lstlisting}
function indexOf (int[] items, int item) -> (int r)
ensures r == |items| || items[r] == item:

    int i = 0

    while i < |items|
      where i >= 0 && i <= |items|:

        if items[i] == item:
            break
        i = i + 1

    return i
\end{lstlisting}
\caption{Verifiable Whiley code to find index of an item in an array}
\label{lst:whiley-ex-1}
\end{figure}

% loop patterns
Since the proposal it has become clear that simple loop invariants are
akin to design patterns for loops.
From studying a known loop pattern properties can be derived from it.
Such as figure~\ref{lst:whiley-ex-1} that has a common loop pattern of
iterating an array via an index variable.
From this pattern you know that that during the loop that the index will be
within bounds of the array.
This can be exploited by statically detecting the loop patterns and assisting
the Whiley Compiler by generating loop invariants.

\subsection*{1.3 Overview}

This report covers the work complete for this project so far.
This includes: the background research into key concepts and the state of the
art of formally verified software, loop invariants and their generators;
A summary of the current design of the solution and details of the
implementation of the two current loop invariants generators ;
a summary of the future plans for the project and where the project
is heading next ; and, a request for help.

\section*{2. Background}
% This should discuss any existing solutions to the given problem,
% and may reference academic papers,  books and other sources as appropriate.   Care
% should be taken to identify key differences between these solutions,  and that being
% developed in the project. (3-4 pages)

This project draws from the research in the field of formal software verification.
The project is based off the Whiley language which supports formal software
verification. % Dafny is an alternative choice for formal software verification.
The concept of loop invariants are a necessity is a key to this project.

Formal methods is an application of mathematics to prove software and hardware
systems against a given specification. % TODO: cite this
Formal software verification is the specific application to software with
the intention to prove its correctness.

% TODO: fix this stuff

% intro

\subsection*{2.1 Formal Software Verification Languages}
%% Formal Software Verification
% goals of class of languages (could be covered in Whiley)

There are many languages that are centered around being verifiable
with formal methods.
This is due to the grand challenge of computer science
to create a \textit{verifying compiler} set out by Prof. Sir Tony Hoare \cite{Hoare-grand}.
The Whiley compiler is designed to be verifying compiler \cite{whiley-origin}.
% An alternative to Whiley is the Dafny compiler.

\subsubsection*{2.1.1 Whiley}
%% Whiley
% whiley design paper

The Whiley language was built from the ground up with the idea to be used with
a verifying compiler \cite{whiley-origin}.
The tool set of Whiley includes a compiler that targets an intermediate
language. From the intermediate language the Whiley theorem prover can reason
about the given program \cite{whiley-design} \cite{whiley-origin}.
Since Whiley is an open source project and the primary contributor, David
J.Pearce, is on staff at Victoria University of Wellington this made Whiley a
prime candidate language to extend.

% \todo{could probably add more here}

% \cite{whiley-design}
% \cite{whiley-arrays}

% \subsubsection*{2.1.2 Dafny}
% % dafny - other formal languages

% An alternative to the Whiley language is the Dafny.
% Dafny is a research language for a verifying compiler by Microsoft
% \cite{dafny-lang}.
% The language shares a majority of the same features as 


% \todo{dafny alternative}
% \cite{dafny-started}
% \cite{dafny-lang}


\subsection*{2.2 Loop Invariants}
%% Loop invariants
% overview of loop invariants
% Theorem prover knows nothing about loop invariants - must give all
% * must hold at entry
% * must hold each iteration
% * must hold on exit
%
% * implies post-condition
% * implied by pre-condition

Loop invariants are a means to provide a specification for a loop.
A loop invariant is required to prove the properties of a variable
that is altered during the loop.
It is used to as the basis for an inductive proof of a
property that is to be maintained.
The entry of the loop, each iteration of the loop and the exit of the
loop.

At the entry of the loop the loop invariant must hold.
This results in that the pre-condition of the loop must imply
the loop invariant.
This is illustrated in figure~\ref{lst:whiley-inv} where pre-condition
before entering the loop is clearly that \code{i} equals 0 and that holds
true for the invariants, in particular that \code{i >= 0}.

$$\text{Entry} \quad P \implies I$$

With each iteration of the loop the invariant must still hold.
Since the loop continue to iterate the condition of the loop
also holds. Thus each iteration can be described as a conjunction
between the invariant and the condition.

$$\text{Iteration} \quad I \wedge C $$

On exit of the loop the loop invariant must still hold.
Since the loop has ceased the loop condition no longer
holds. Thus an exit of the loop can be described
as the conjunction of loop invariant and the logical
not of the loop condition.
This results in an implication of the post-condition of the
loop.

$$\text{Exit} \quad I \wedge \neg{C} \implies Q$$

Figure~\ref{lst:whiley-inv} illustrates this as the
post condition of the loop can be reasoned to be the following
from the loop condition and the invariant:
$$\neg{ ( i < |items| ) } \wedge i \leq |items| \wedge i \geq 0$$

This can be simplified to down:

$$ i = |items| \wedge i \geq 0$$

This implies the post-condition of the function that $r = |items|$ with
the variable \code{i} renamed to \code{r}.
Each of the stages of a loop are similar to building an inductive proof \cite{invarints-classifiction}.

\subsubsection*{2.2.1 Loop Invariants in Whiley}

In the Whiley language the concept of loop invariants are a 1\textsuperscript{st} class
construct.
Whiley gives syntax for providing \code{where} clauses to a \code{while}
statement.
Each of the \code{where} has a boolean expression which is the loop
invariant predicate.
Having multiple \code{where} clauses are equivalent to all the clauses are
conjunctively joined.
Figure~\ref{lst:whiley-inv} gives a full example of using a loop invariant
in Whiley. The \code{where} clauses on lines 6 and 7 are Whiley's syntax for
providing the loop invariant in the form of a predicate.

\begin{figure}[ht]
\begin{lstlisting}
function count(int[] items) -> (int r)
ensures r == |items|:
    int i = 0
    //
    while i < |items|
        where i >= 0
        where i <= |items|:
        i = i + 1
    //
    return i
\end{lstlisting}
    \caption{Example of loop invariant in Whiley (
    \href{http://whiley.org/play/?id=DzLm1T}{Try snippet} ) }
    \label{lst:whiley-inv}
\end{figure}

\subsubsection*{2.2.2 Classification of loop invariants}
% classification of loop invariants
%  * proves property
%  * hints to theorem prover
% example

There are two classifications of loop invariants.
These are bounding loop invariants and essential invariant
\cite{invarints-classifiction}.
With the classification of a loop invariant it helps to make
it clearer what the purpose of the invariant is trying to achieve.

A \textit{bounding loop invariant} is an invariant that is designed
to limit the values of a variable.
Figure~\ref{lst:whiley-inv} has an example of this at line 6, as the invariant
ensures that the variable \code{i} is bounded to be greater than zero
in every iteration of the loop.
Generally these types of invariants are used to ensure the body of the loop
is correct. In the case of figure~\ref{lst:whiley-ex-1} the loop invariant on line
7 do no effect the post-condition but ensures that the array indexing within
the loop is correct.

An \textit{essential invariant} is an invariant that is a step towards the
post-condition.
Figure~\ref{lst:whiley-inv} has an example of this at line 7,
as the invariant shows \code{i} must be less than or
equal to the length of the \code{items} array.
The loop invariant is a weaker form of the postcondition,
since the conjunction of the loop invariant and the negation
of the loop condition imply the postcondition \cite{invarints-classifiction}.
This class of invariant are more tailored to achieve
the goal of the loop than bounding invariants.


\subsection*{2.3 Methods to generate loop invariants}
%% Methods to generate loop invariants
% generally generating loop invariants are impossible!

The current state of the art can already generate some loop invariants
from source code.
It has been proven that it is not possible to generate loop invariants
generally % TODO: cite this
so various techniques have been developed to generate some invariants.
These techniques can be classified into two categories,
static inference and dynamic checking.
The key difference between the categories is
that invariants found statical hold true
but is restricted to what can be generated.
\cite{benderfinding}\cite{Leino2005LoopIO}.
However, dynamic
checking are techniques that may produce a valid invariant
but multiple rounds of testing is required
\cite{infer-dynamic}
\cite{infer-postconditions}.

% \subsubsection*{2.3.3 Inference Paradox}
% issue with inference creates correct code
% by making specification from code
% OK since it is at such a small scale with limited scope

% \todo{invariant inference paradox}
% \cite{infer-postconditions}


\section*{3. Work Done}
% This should discuss what progress has been made on designing, implementing
%  and evaluating the artifact. Care must be taken to ensure that any discussion
% of technical points are clearly explained, with diagrams being used where appropriate.
% In many cases, the evaluation proper will not yet have begun. However, it is important
% to demonstrate that sufficient thought has been given to the evaluation.
% (2 pages)

The work done to date is multiple loop patterns have been implemented and
tested. The design of the extension to the Whiley compiler attempts follow
the rest of the design of the project.

\subsection*{3.1 Design}

Since the Whiley compiler has multiple passes over the abstract syntax tree
(AST)
the current design adds a new pass. The compiler passes runs checks of properties
of the program such as the definite assignment of variables and sound usage of
types. This project adds an additional pass that searches for loop patterns and
inserts generated code into the AST.
This has been called the Loop Invariant Generator (LIG) pass.
This is akin to a modern macro system operating directly onto the AST.

The overall design of the Loop Invariant Generator is to collect the required
information before a loop to be used to infer loop invariants.
This is using forward propagation to determine if the
information collected is safe to use. Once the LIG reaches a loop
it tests the loop to see if it fits a loop pattern. This has been
designed using the strategy pattern, where each loop pattern is encoded
into a single strategy and produces a single invariant.
The invariant is known to be valid since they are built up via language
semantics.

This is in contrast with other state of the art loop invariant generators.
The general design of other loop invariant generators are to infer a set
of possible invariants and iterate through them trying to prove which
invariants are valid \cite{infer-dynamic} \cite{infer-postconditions}.
However, these loop invariant generators have the design to be used as a tool
to use with the source code where this project aims to integrate with the
compiler itself. Being apart of the compiler imposes multiple constraints.
This includes a constraint on keeping the impact on compile time to a
reasonable level.
Another constraint to consider is to not fail compilation for otherwise valid
code to ensure backwards compatibility and reduce surprise to the user.
Conversely should an error occur the resulting error message should not be
confusing, such as referring to generated code.

\subsection*{3.2 Implementation}
%% Implemented so far
% implemented algorithms for generating invariants
%  * entry value of a simple mutation and its sequence
%  * array length of a generated / copied array


From the work completed thus far there two loop patterns and their invariants
have been implemented. The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiley-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another.
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.

\subsubsection*{3.2.1 Starting value invariant}
% entry value

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.
The loop invariant inferred is a bounding invariant.

The definition of a simple mutation is restricted to an expression that only
includes addition and subtraction of constant values and the variable in question.
The mutation must be certain with each iteration so the variable must not be
modified inside branching statements such as \code{if} blocks or nested loops.
Since the mutation has to be simple it restricts them to linear monotonic
functions that is either strictly increasing or decreasing the variable with each iteration.
This is to keep the loop pattern simple and deterministic of knowing if the
mutation is increases or decreases the variable with each iteration.
An expression is checked if it is a simple mutation through static analysis of
the AST.

\begin{figure}
    $$f(x) \text{is a linear function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
\label{math:simple-mutation}
\end{figure}

The increase or decreasing nature of the simple mutation it is determined by
executing the expression. An outline of the mathematical process is outlined
in figure~\ref{math:simple-mutation}, the expression is denoted with $f(x)$.
The equations show how the difference between applying the function twice and once on a base value is used to
determine if the function increases or decreases.
In the case that the expression is stationary the variable will not variate
between iterations and left alone.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

With the identification of the variable with a simple mutation and knowing
if it decreases or increases each iteration an invariant can be made.
This is in the form of the variable on the left with either a less than or
equal to ($\leq$) or greater than or equal to ($\geq$) to the initial value on the
right.
In figure~\ref{lst:whiley-start} the variable \code{i} is clearly increasing
with each iteration due to line 7 and the inferred invariant, on line 5, is
obvious from the context.

\subsubsection*{3.2.2 Equal length arrays invariant}
% array length

From a common pattern of making a copy of arrays or generating another array
with an equal length an invariant can be inferred.
This loop pattern is found when applying a function that changes the type of
the element or the user does not wish to update the original array.
Figure~\ref{lst:whiley-length} shows a simple example of applying a function
\code{apply ()} to each element of an array.
Generally the user would also need to provide an invariant that both arrays
have the same length to prevent possible out-of-range errors or prove a
post-condition.
The loop invariant inferred is a bounding invariant.

With this invariant it is detected that an array is declared with the same
length as another array.
This is achieved by inspecting the AST of the program
using forward propagation to find assignments to arrays.
Due to Whiley's copy semantics it is known that the assignment will result
in a clone of array and are distinct \cite{whiley-origin} \cite{whiley-arrays}.
This can also be achieved by finding a use of the array
generator syntax, see line 4 of figure~\ref{lst:whiley-length}.

The arrays that are shown to be equal in length to another array are
check to ensure the array size does not change.
This is achieved by checking that there is no assignments to either
of the two arrays involved either before entering the loop or
anyway inside the loop.
If there was an assignment it is no longer a simple to infer if
the arrays are equal size and an invariant is not generated.
However, an assignment to an element of the array is passable since it
is known that it won't change the array size just the contents.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    float[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        copy[i] = apply(items[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

From this information an invariant is known and can be generated.
Given the source array and the array of known equal length the
invariant of the lengths are equal.
See figure~\ref{lst:whiley-length} line 5 for the invariant generated
from the example code.

\subsection*{3.3 Evaluation}
%% Evaluation
% measurable deduction of proof obligations
% # of total loops effected

The evaluation of this project is to study reduction of required loop
invariants.
To measure the reduction a sizable code base that is also formally verifiable
is required to test against.
Currently the largest known code is the Whiley Compiler test suite.
The body of code will be filtered down to examples that contain loop
invariants for experiments.
These studies include checking how closely the generated invariants match
user given invariants,
what percentage of the loop invariants have been generated
and if the loop invariant are required.
From these studies the impact of generating simple loop invariants on
the proof obligations of the user can be accessed.

\section*{4. Future Plan}
% This should highlight the main components which remain to be done,
% and provide a proposed time-line in which this will happen. In putting together a time
% line, students must take into account upcoming examinations, coursework deadlines
% and other disruptions.
% (1 pages)

There are a range of improvements and additions that could be completed in
the time remaining of this project.
There could be improvements to the quality of the implementation with
the addition of more tests and documentation.
There could be additions of support for more loop patterns or tooling
to let the user control which loop patterns are used.
Some of these are more stretch goals if there is time and
others are more immediate concerns.

\subsection*{4.1 To be done}
% identify common loop patterns to  study & codify
% found a few
%   * map pattern - loops through array applying function to each element
%   * for all - simple loop to see if all elements satisfies a condition
%   * for some - simple loop until an element satisfies a condition

The immediate goals for the project is to implement some additional loop
patterns or to expand on more cases for existing loop patterns.
Some loop patterns have been identified but not yet
fully specified to a point that a loop pattern can be implemented.
These are:
\begin{itemize}
    \item Expanding the starting value invariant to handle branches
        and inner loops by using formal static analysis techniques.
    \item Ending value of a loop, in the same vain of thought as the Starting
        Value invariant but attempting to detect the maximum value of the loop.
        This would be common when iterating arrays and the loop condition does
        not imply the maximum.
    \item Applying a function to every element in an array, such as a
        functional `map' and provide an invariant for the values.
        This would likely require the use of universal quantifiers
        and a copy of the original array in the invariant.
    \item Checking if all elements in an array meet a condition, such as
        a `for all' universal quantifier, as well as a `for some' universal
        quantifier.
        This would require universal quantifiers in the invariant.
\end{itemize}

The project has a set of key dates over the next few months.
These have been outlined in figure~\ref{list:timeline}.

\begin{figure}[ht]
    \begin{itemize}
        \item Practise Presentations (24\sth to 28\sth of July)
        \item Draft Report (15\sth of September)
        \item Project Snapshot (29\sth of September)
        \item Final Report (22\snd of October)
        \item Presentation (17\sth of November)
    \end{itemize}
    \caption{Revised project timeline}\label{list:timeline}
\end{figure}

\subsection*{4.2 Stretch goals or future work}

Some stretch goals have been identified for this project that could
be completed if enough time or be ideas for future projects.
These include adding user controls over this extension in the
form of compiler flags, or detecting the duplication of an invariant,
or a functional fold notation for proofs.

% stretch: User controls
\subsubsection*{4.2.1 User Controls}
From a usability standpoint it would be a great addition to expose
some configuration of the loop invariant generators to the user.
This would most likely come in the form of compiler flags or even
a configuration file. The GNU compilers and their handling of
extension flags would be a good model to follow.

% stretch: Proof duplication detection
\subsubsection*{4.2.2 Invariant duplication detection}
With the addition of generated invariants there now may be
duplicates of invariants. A possible solution to resolve this would
be to warn the user if there is a detected duplication and
inform them how it was duplicated.
The duplication could be detected by syntactic or logical equivalence.
With this information the user can be informed with a warning message.
This feature would help the user to understand when the loop invariant
generators can be used.

% stretch: sum notation for Whiley
\subsubsection*{4.2.3 Fold notation for Whiley}
From my research into trying to prove the fundamental functional functions of
map, fold and for-all and for-some Whiley is missing the notation to prove
these ergonomically. The main pain point comes from trying to code a fold-like
function that require a changing state between each iteration. Currently this
can be achieved by using recursive function calls in proofs but this seems to
be a stop-gap solution. A possible solution to this problem is the
introduction of a fold syntax such as `for some' or `for all' syntax that
already exists in Whiley. The requirements for the fold syntax would require
an initial state, a combination expression that evaluates to the next state
and a variable for the current state.
The largest issue with this suggestion is in how to encode this new structure
so the Whiley theorem prove can understand and prove it.

\section*{5. Request for Feedback}
% This should  highlight  any  difficulties  currently  faced,  and
% make specific requests for guidance from the examination committee.  For example,
% a student  may  be  unsure  how  best  to  evaluate  their  artifact,  and  would  appreciate
% suggestions for alternative methods.
% (1 pages)

%% Difficulties
% Additional ways to evaluate success

A current difficulty with the project is that I am unsure that the current
evaluation criteria is sufficient.
This is due to the only evidence the current criteria provides is a change set
of removed lines and passing cases. I would appreciate some guidance on
improving this or possible alternatives.

%% Help
% Suggested invariant patterns


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\bibliographystyle{ieeetr}
\bibliographystyle{acm}
\bibliography{report}

\includepdf[pages={1,3-5,7}]{../proposal/proj_proposal.pdf}

\end{document}

