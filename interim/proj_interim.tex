\documentclass[11pt, a4paper, twoside, openright]{report}

\usepackage{float} % lets you have non-floating floats

\usepackage{listings}
\usepackage{color}
\usepackage{url} % for typesetting urls
\usepackage{mathtools}
% \usepackage{pdfpages} % for including PDF's into the document
\usepackage[parfill]{parskip}

%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

\definecolor{grey}{rgb}{0.95,0.95,0.95}

\lstset{%
    backgroundcolor=\color{grey},
    frame=single,
    numbers=left
}

%% These are standard LaTeX definitions for the document
%%
\title{Generating simple loop invariants for Whiley}
\author{David Barnett}

%% This file can be used for creating a wide range of reports
%%  across various Schools
%%
%% Set up some things, mostly for the front page, for your specific document
%
% Current options are:
% [ecs|msor|sms]          Which school you are in.
%                         (msor option retained for reproducing old data)
% [bschonscomp|mcompsci]  Which degree you are doing
%                          You can also specify any other degree by name
%                          (see below)
% [font|image]            Use a font or an image for the VUW logo
%                          The font option will only work on ECS systems
%
\usepackage[image,ecs]{vuwproject} 

\supervisors{Lindsay Groves}
\otherdegree{Bachelor of Engineering with Honours in Software Engineering}

% Comment this out if you want the date printed.
\date{}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
    % TODO: abstract
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{1. Introduction}
% This should briefly outline the project and if necessary 
% reevaluate the original plan in light of what has been learned in the interim.  In
% particular, any significant deviations in the problem being addressed, or the solution
% being developed should be clearly highlighted and justified. (1 pages)
%% TODO: Also have the proposal as an appendix

% outline 
Whiley is a programming language that can be used for formal software
verification. One aspect of formal software verification is providing loop
invariants.
The primary goal of this project is to relieve some proof obligations from a
Whiley programmer by automatically providing some simple loop invariants.
Instead the loop invariants are generated by the Whiley Compiler itself.
This project does not attempt to generate loop invariants generally, as it is
known to be uncomputable, but generates invariants for specific common cases.

\subsection*{1.1 Motivation}

% Why
The purpose of this project is to make Whiley more usable in practise.
Loop invariants are a common pain point for users of formally verified
languages. Simple loop invariants are repetitive and become a chore to
always provide them. With this project some of this pain is alleviated.

% Changes since proposal

\subsection*{1.2 Solution}

% brief overview of solution

% 'simple'
The definition of a simple loop invariants for this project is an invariant that is
obvious at inspection that an invariant both exists and holds.
An example would be that while iterating through an array the index
will not go out of bounds of the array, such as figure~\ref{lst:whiley-ex-1}.
The purpose of having a strict definition of an simple invariant is to prevent
possible confusion when what looks to be unproven code is verified and to point
the scope of the project away from being too general, such as supporting
a rare scenarios such as indexing an array with a polynomial equation.
This leaves the more interesting invariants for the user to define.

\begin{figure}[h]
\begin{lstlisting}
    function indexOf (int[] items, int item) -> (int r)
    ensures r == |items| || items[r] == item:

    int i = 0

    while i < |items|
      where i >= 0 && i <= |items|:

        if items[i] == item:
            break
        i = i + 1

    return i
\end{lstlisting}
\caption{Verifiable Whiley code to find index of an item in an array}
\label{lst:whiley-ex-1}
\end{figure}

% loop patterns
Since the proposal it has become clear that simple loop invariants are
akin to design patterns for loops.
From studying a known loop pattern properties can be derived from it.
Such as figure~\ref{lst:whiley-ex-1} that has a common loop pattern of
iterating an array via an index variable.
From this pattern you know that that during the loop that the index will be
within bounds of the array.
This can be exploited by statically detecting the loop patterns and informing
the Whiley Compiler of these properties.

\section*{2. Background}
% This should discuss any existing solutions to the given problem,
% and may reference academic papers,  books and other sources as appropriate.   Care
% should be taken to identify key differences between these solutions,  and that being
% developed in the project. (3-4 pages)

% intro

%% Formal Software Verification
% goals of class of languages (could be covered in Whiley)

%% Whiley
% whiley design paper
\cite{whiley-origin} \cite{whiley-design}

% dafny - other formal languages
\cite{dafny-started}


%% Invariants
% always holds

%% Loop invariants
% overview of loop invariants
% classification of loop invariants
% example

%% Methods to generate loop invariants
% generally generating loop invariants are impossible!
% infer dynamic
% finding invariants via static analysis

\section*{3. Work Done}
% This should discuss what progress has been made on designing, implementing
%  and evaluating the artifact. Care must be taken to ensure that any discussion
% of technical points are clearly explained, with diagrams being used where appropriate.
% In many cases, the evaluation proper will not yet have begun. However, it is important
% to demonstrate that sufficient thought has been given to the evaluation.
% (2 pages)

The work done to date is multiple loop patterns have been implemented and
tested. The design of the extension to the Whiley compiler attempts follow
the rest of the design of the project.

\subsection*{3.1 Design}

Since the Whiley compiler has multiple passes over the abstract syntax tree
(AST)
the current design adds a new pass. The compiler passes runs checks of properties
of the program such as the definite assignment of variables and sound usage of
types. This project adds an additional pass that searches for loop patterns and
inserts generated code into the AST.
This has been called the Loop Invariant Generator (LIG) pass.
This is akin to a modern macro system operating directly onto the AST.

The overall design of the Loop Invariant Generator is to collect the required
information before a loop to be used to infer loop invariants.
This is using forward propagation and static analysis to determine if the
information collected is safe to use. Once the LIG reaches a loop
it tests the loop to see if it fits a loop pattern. This has been
designed using the strategy pattern, where each loop pattern is encoded
into a single strategy and produces a single invariant.
The invariant is known to be valid since they are built up via language
semantics.

\subsection*{3.2 Implementation}

From the work completed thus far there two loop patterns and their invariants
have been implemented. The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiely-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another. 
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.

%% Implemented so far
% implemented algorithms for generating invariants
%  * entry value of a simple mutation and its sequence
%  * array length of a generated / copied array

% Found that this method is requires a code pattern to exploit
% a characteristic of it so it can then be able to generate it

\subsubsection*{3.2.1 Starting value Invariant}

% entry value

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being 
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.


A simple mutation is restricted to only include addition and subtraction of
constant values and the variable in question.
This restricts the mutation to be a linear monotonic function that is either strictly
increasing or decreasing the variable with each iteration.
This is to keep the loop pattern simple and deterministic of knowing if the
mutation is increases or decreases the variable with each iteration.

\begin{figure}

$$f(x) \text{is a linear function}$$

$$diff = f(f(0)) - f(0)$$

\[
diff \begin{cases}
= 0 \quad f(x) \text{ is stationary}\\
> 0 \quad f(x) \text{ is increasing}\\
< 0 \quad f(x) \text{ is decreasing}\\
\end{cases}
\]

\label{math:simple-mutation}
\end{figure}

The increase or decreasing nature of the simple mutation it is determined by
executing the function. An outline of the mathematical process is outlined 
in figure~\ref{math:simple-mutation}. The equations show how the difference 
between applying the function twice and once on a base value is used to
determine if the function increases or decreases.


\begin{figure}[h]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

% array length

\begin{figure}[h]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    int[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        items[i] = apply(copy[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

\subsection*{3.3 Evaluation}

%% Evaluation
% measurable deduction of proof obligations
% # of total loops effected

The evaluation of this project is to measure reduction of required loop
invariants. 
To measure the reduction a sizable code base that is also formally verifiable
is required to test against.
Currently the largest known code is the Whiley Compiler test suite.
Thus the evaluation is removing loop invariants from the test suite and
ensuring they are still formally verified.
So far this has been a success with a majority of loops have been simplified.

\section*{4. Future Plan}
% This should highlight the main components which remain to be done,
% and provide a proposed time-line in which this will happen. In putting together a time
% line, students must take into account upcoming examinations, coursework deadlines
% and other disruptions.
% (1 pages)

% identify common invariant/loop patterns to codify
% found a few 
%   * map pattern - loops through array applying function to each element
%   * for all - simple loop to see if all elements satisfies a condition
%   * for some - simple loop until an element satisfies a condition

% stretch: User controls
% stretch: Proof duplication detection

\section*{5. Request for Feedback}
% This should  highlight  any  difficulties  currently  faced,  and
% make specific requests for guidance from the examination committee.  For example,
% a student  may  be  unsure  how  best  to  evaluate  their  artifact,  and  would  appreciate
% suggestions for alternative methods.
% (1 pages)

%% Help
% Suggested invariant patterns


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\bibliographystyle{ieeetr}
\bibliographystyle{acm}
\bibliography{report}

\appendix
% \includepdf[pages={1,3-5,7}]{../proposal/proj_proposal.pdf}

\end{document}

