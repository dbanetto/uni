\chapter{Background}\label{C:background}
\comment{
The background should cover any important terminology and/or
concepts used in the remainder of the report, and should demonstrate an
understanding of previous works which are relevant.

Remember: A good related work section does not just provide a list of previous works,
accompanied with short summaries.
Wherever possible it must extract real insight from these works, painting a
picture of how they relate to each other and the project.
}


This project draws from the research in the field of formal software verification.
The project is based off the Whiley language which supports formal software
verification.
The concept of loop invariants are a necessity is a key to this project.

Formal methods is an application of mathematics to prove software and hardware
systems against a given specification. \todo{cite this}
Formal software verification is the specific application to software with
the intention to prove its correctness.

\todo{fix this stuff}


\section{Core Concepts}

\subsection{Formal Software Verification Languages}
\comment{
 * Formal Software Verification \\
 * goals of class of languages (could be covered in Whiley)
}

Formal software verification is a field of software engineering with the
purpose to create software that is able to be mathematically verified to be
correct \cite{survey-formal-soft}.
Prof. Sir Tony Hoare issued a grand challenge to create a \textit{verifying compiler}
that guarantees the correctness of the program before running it \cite{Hoare-grand}.
There has been tool sets that expand languages to achieve this, such as
the SPARK tool set for the Ada \cite{spark-ada}\cite{spark-high-integ}.
Though this generally restricts the functionality of the language, for example
using Ada with SPARK disallows the use of pointers which makes general purpose
programming more challenging relative to C \cite{spark-ada}.
There are some languages that are designed and built from the ground up to
be a formal software language and have a \textit{verifying compiler}.
These languages include such as Whiley \cite{whiley-origin} and Dafny \cite{dafny-lang}.

\subsection{Language Semantics}
\comment{
    Explain the basics of reading language semantics \\
    explain how to read a semantics thing, with the $\frac{pre-cond}{post-con}$
}

\subsection{Whiley}
\comment{
Whiley \\
 * goals of the lang \\
 * samples of code \\
 * whiley design paper \\
}

The Whiley language is a general purpose language that has first class
support for formal software verification through its syntax and compiler
tool set \cite{whiley-origin}.
The design goal for Whiley is to make a platform for formal verifications \cite{whiley-origin}.
The tool set includes the compiler and an accompanying theorem prover.
The compiler translates the source code as an intermediate language which
can then be used with the theorem prover or transforms it into a target
language such as JVM byte code or JavaScript \cite{whiley-design}
\cite{wyil}.
Since Whiley is an open source project and the primary contributor, David
J.Pearce, is on staff at Victoria University of Wellington this made Whiley a
prime candidate language to extend.


\subsubsection{Whiley Semantics}
\comment{
Cover the key semantics used in the loop invariants \\
These are semantics that may differ languages so will be covered \\
* while loops \\
* where clause \\
* array copy \\
* array generator
}

In this section there are three key semantics used, while loops with where
clause, copy semantics and array generators.
The Whiley language specification book is available for the full
specification of the language \cite{whiley-spec}.

\paragraph{While loops with where clauses} are the mechanism for the programmer
to inform the compiler and theorem prover with loop invariants.
Figure~\ref{lst:whiley-where} shows an example of using where clauses with a
while loop in Whiley.
Each of the \code{where} clauses are joined together logically conjunctively.
Thus the logical loop invariant for the loop in figure~\ref{lst:whiley-where} would be:

$$(i >= 0 \wedge i <= 10) \wedge i < 10$$

\begin{figure}[ht]
\begin{lstlisting}
int i = 0
while i < 10
    where i >= 0
    where i <= 10:
    i = i + 1
\end{lstlisting}
    \label{lst:whiley-where}
    \caption{Example usage of a \code{where} clause in Whiley}
\end{figure}

\paragraph{Copy semantics} is a design decision of Whiley to
make clones of data instead of referencing the data on assignment \cite{whiley-array}.
Figure~\ref{lst:whiley-array-copy} shows an example of the variable
\code{b} making a copy of \code{a} and that mutating \code{a} later
will have no affect on the value of \code{b}.
This is an important feature of Whiley as it disassociates the data
of the variables after they are copied which allows for simpler verification
and disallows accidental mutations by unknown references \cite{whiley-array}.
Whiley does support explicit references to data but they also include
lifetimes to how long the references can live to remove null reference errors,
similar to Rust's lifetimes \cite{rust-lang}.

\begin{figure}[ht]
\begin{lstlisting}
a = [1, 2, 3]
b = a
assert a == b
assert |a| == |b|

a[0] = 2
assert a != b
assert |a| == |b|
\end{lstlisting}
    \label{lst:whiley-array-copy}
    \caption{Example an array copy in Whiley}
\end{figure}

\paragraph{Array generator} is a feature in Whiley to generate an array
of a specific element duplicated over a specific size.
Figure~\ref{lst:whiley-array-gen} shows an example of using an array generator
in Whiley and its associated results.
This is a short hand for creating arrays with a default value which is useful
to

\todo{finish me}

\begin{figure}[ht]
\begin{lstlisting}
a = [0; 3]

assert |a| == 3
assert |a| == [0, 0, 0]
\end{lstlisting}
    \label{lst:whiley-array-gen}
    \caption{Example an array generator in Whiley}
\end{figure}

\cite{whiley-design}
\cite{whiley-arrays}

\subsection{Loop Invariants}
\comment{
Loop invariants - overview of loop invariants
Theorem prover knows nothing about loop invariants - must give all \\
* must hold at entry \\
* must hold each iteration \\
* must hold on exit \\
* implies post-condition \\
* implied by pre-condition \\
}

Loop invariants are a means to provide a specification for a loop.
A loop invariant is required to prove the properties of a variable
that is altered during the loop.
It is used to as the basis for an inductive proof of a
property that is to be maintained.
The entry of the loop, each iteration of the loop and the exit of the
loop.

At the entry of the loop the loop invariant must hold.
This results in that the pre-condition of the loop must imply
the loop invariant.
This is illustrated in figure~\ref{lst:whiley-inv} where pre-condition
before entering the loop is clearly that \code{i} equals 0 and that holds
true for the invariants, in particular that \code{i >= 0}.

$$\text{Entry} \quad P \implies I$$

With each iteration of the loop the invariant must still hold.
Since the loop continue to iterate the condition of the loop
also holds. Thus each iteration can be described as a conjunction
between the invariant and the condition.

$$\text{Iteration} \quad I \wedge C $$

On exit of the loop the loop invariant must still hold.
Since the loop has ceased the loop condition no longer
holds. Thus an exit of the loop can be described
as the conjunction of loop invariant and the logical
not of the loop condition.
This results in an implication of the post-condition of the
loop.

$$\text{Exit} \quad I \wedge \neg{C} \implies Q$$

Figure~\ref{lst:whiley-inv} illustrates this as the
post condition of the loop can be reasoned to be the following
from the loop condition and the invariant:
$$\neg{ ( i < |items| ) } \wedge i \leq |items| \wedge i \geq 0$$

This can be simplified to down:

$$ i = |items| \wedge i \geq 0$$

This implies the post-condition of the function that $r = |items|$ with
the variable \code{i} renamed to \code{r}.
Each of the stages of a loop are similar to building an inductive proof \cite{invarints-classifiction}.

\subsubsection{Loop Invariants in Whiley}

In the Whiley language the concept of loop invariants are a 1\textsuperscript{st} class
construct.
Whiley gives syntax for providing \code{where} clauses to a \code{while}
statement.
Each of the \code{where} has a boolean expression which is the loop
invariant predicate.
Having multiple \code{where} clauses are equivalent to all the clauses are
conjunctively joined.
Figure~\ref{lst:whiley-inv} gives a full example of using a loop invariant
in Whiley. The \code{where} clauses on lines 6 and 7 are Whiley's syntax for
providing the loop invariant in the form of a predicate.

\begin{figure}[ht]
\begin{lstlisting}
function count(int[] items) -> (int r)
ensures r == |items|:
    int i = 0
    //
    while i < |items|
        where i >= 0
        where i <= |items|:
        i = i + 1
    //
    return i
\end{lstlisting}
    \label{lst:whiley-inv}
    \caption{Example of loop invariant in Whiley}
\end{figure}

\subsection{Classification of Loop Invariants}
\comment{
classification of loop invariants
 * proves property \\
 * hints to theorem prover \\
 * examples \\
}

There are two classifications of loop invariants.
These are bounding loop invariants and essential invariant
\cite{invarints-classifiction}.
With the classification of a loop invariant it helps to make
it clearer what the purpose of the invariant is trying to achieve.

A \textit{bounding loop invariant} is an invariant that is designed
to limit the values of a variable.
Figure~\ref{lst:whiley-inv} has an example of this at line 6, as the invariant
ensures that the variable \code{i} is bounded to be greater than zero
in every iteration of the loop.
Generally these types of invariants are used to ensure the body of the loop
is correct. In the case of figure~\ref{lst:whiley-ex-1} the loop invariant on line
7 do no effect the post-condition but ensures that the array indexing within
the loop is correct.

An \textit{essential invariant} is an invariant that is a step towards the
post-condition.
Figure~\ref{lst:whiley-inv} has an example of this at line 7,
as the invariant shows \code{i} must be less than or
equal to the length of the \code{items} array.
The loop invariant is a weaker form of the postcondition,
since the conjunction of the loop invariant and the negation
of the loop condition imply the postcondition \cite{invarints-classifiction}.
This class of invariant are more tailored to achieve
the goal of the loop than bounding invariants.

\subsection{Categories of Generated Loop Invariants}
\comment{
Methods to generate loop invariants \\
Generally generating loop invariants are impossible! \\
}

It has been proven that it is not possible to generate loop invariants
generally % TODO: cite this
so various methods have been developed to generate some invariants.
These methods can be sorted into one of two categories, static and dynamic.
This section will give an overview of static and dynamic methods of loop
invariants.

\subsubsection{Static Generation of Loop Invariants}

The static generation of loop invariants use the
semantics and analysis of the source code to generate the loop invariants.
This includes the use of language semantics and static analysis to

The key difference between the categories is
that invariants found statical hold true
but is restricted to what can be generated.
\cite{benderfinding}\cite{Leino2005LoopIO}.
The solution presented in this report uses
the principles of static methods to generate loop invariants.

\subsubsection{Dynamic Generation of Loop Invariants}

Dynamic generation of loop invariants involves static inference
with execution of the program to confirm the results.
This allows for a greater range of invariants to be inferred
at the cost of time to verify from testing potential invariants
\cite{infer-dynamic} \cite{infer-postconditions}.
This makes dynamic generation less suited to be apart of
the general compile-test-run development cycle common in general development.

\subsection{Static Analysis}
\comment{overview of static analysis techniques \\
e.g. partial ordered sets, lattices
}

\subsection{Inference Paradox}
\comment{
issue with inference creates correct code
by making specification from code

OK since it is at such a small scale with limited scope
}

\todo{invariant inference paradox}
\cite{infer-postconditions}

\subsection{Loop Design Pattern}

A loop design pattern is similar to an architecture pattern.
In that they can be classified into groups by there intent of
the pattern and how they are implemented.
For example, a strategy pattern is implemented to enable changes of
behaviour dependent on some input by utilising interfaces.
An example of a loop pattern would be a search through
an array for an element or processing all elements of an array
\cite{loop-patterns}.
A loop pattern can be described in the same terms of an architectural pattern
by providing the following outline from figure~\ref{l:design-pattern}
from \textit{A Pattern Language} \cite{pattern-lang}.

\begin{figure}[ht]
\begin{itemize}
    \item{\textbf{Examples} of pattern in application}
    \item{\textbf{Context} in which the pattern is used}
    \item{\textbf{Problem} that the pattern addresses or solves}
    \item{\textbf{Forces} requirements or trade offs that constrain possible
        solutions}
    \item{\textbf{Solution} the pattern}
    \item{\textbf{Resulting Context} having used the pattern, what is needed
        now}
\end{itemize}
    \caption{Elements of a design pattern\cite{pattern-lang}}
    \label{l:design-pattern}
\end{figure}


\cite{pattern-lang}

\section{Related Work}
\comment{Covers the literature review and compare current solution to similar
projects}

\fixme{Should this be in the conclusion section rather than here?}

\subsection{Dafny}
\comment{
explain how dafny is an alternative to Whiley in the Spec Lang space
has some features that are missing in Whiley that would be interesting to use

* declaring variables as increasing or decreasing \\
* defining variables / fields as ghosts, to only be used in specifications \\
dafny - other formal languages \\
}

An alternative to the Whiley language is the Dafny.
Dafny is a research language for a verifying compiler by Microsoft
\cite{dafny-lang}.
The language shares a majority of the same features as

\todo{dafny alternative}
\cite{dafny-started}
\cite{dafny-lang}
\cite{dafny-mech}

\subsection{Methods to Generate Loop Invariants}
\comment{explain how these methods create loop invariants}

\subsubsection{Manual Generation}
\comment{ Manual is always a thing }

\cite{broda-loop-tech}

\subsubsection{Backwards Propagation}

\cite{infer-postconditions}
\cite{infer-dynamic}

\subsubsection{Variable Aging}

\cite{infer-postconditions}
\cite{infer-dynamic}

\subsubsection{Coupling}

\cite{infer-postconditions}
\cite{infer-dynamic}

\subsubsection{Term dropping}

\cite{infer-postconditions}
\cite{infer-dynamic}

\cite{struct-induction}
