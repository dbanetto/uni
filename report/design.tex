\chapter{Design}\label{C:design}
\comment{
The aim here is to identify the key trade-offs in any design work you have undertaken.
When solving a complex problem, there are normally many different
approaches one can take — each with its own advantages and disadvantages.
It is expected that students will have initially considered a range of different solutions,
and will then have narrowed these down. The reasons why a particular approach was
discounted should be documented here.


Remember:
Appropriate design notation (e.g. UML diagrams) can be very helpful in conveying different aspects of a design.
It is vital that your design not be carried out in a vacuum.
Your design should be motivated very clearly by your goals and specifications.
Make sure that it is clear why you took the decisions that you did.
Do not give the impression that you settled on a design because it “felt right”
or that you tinkered around until you found something that worked.

Should cover: \\
 * techniques of loop invariant generation, \\
 * problem analysis \\
 * express the requirements of the solution \\
}

% intro to problem, what is the design space for this issue
%

\fixme{Update to include techniques are here, architectures in impl}

This chapter will discuss the requirements and considerations taken to design the implementation
of this project.
These considerations are derived by the project requirements
and guided by improving or retaining the same level of
usability of the Whiley Compiler for a Whiley developer and a maintainer of the
compiler fixing or updating the modified compiler.
It will also discuss the internal design decisions of
where to place the loop invariants generators in the
current architecture of the Whiley Compiler.
This includes where the generated loop invariants are found and
how they are inserted into the program.
The final design decision discussed is how the multiple generators are managed.

\section{Requirements}
\comment{
    should cover the functional and non-functional requirements
}

The requirements for this project are derived from the original project
outline (see Appendix~\ref{A:proj-outline}).
The base requirements of each loop invariant generator is to be grounded
in practicality of the invariant not the generality of its use cases.
This is to say that it is not worth expanding a loop invariant
generator to cover cases that are unlikely to actually occur for generality
sake.

The other major requirement is that the Whiley compiler will be improved
with the addition of loop invariant generators.
This implicitly includes maintaining the current level of quality or
improving the experience with this extension.

Some parts of the original project outline fell out of scope of this project.
This included the students of SWEN224 would be used to evaluate this solution.
The decision to drop this requirement was in favour of focusing on implementing
many loop invariant generator rather than making a split effort of implementing
less generators so that proper user testing can be completed.
It was also found to be impracticable as the course layout of SWEN224 saw the
Whiley section taught in the last half of the semester with loop invariant in
particular taught in the final weeks making properly timed user studies
impracticable.

\todo{expand on the problem}

\todo{make requirements eat the considerations section}

Below is a list of design considerations that were identified to keep to ensure
that these requirements are met.
Each of these considerations either focus the development of the loop
generators or to force quality control on how they interact with the rest of the
compiler.

\begin{itemize}
    \item{Backward compatibility with non-loop invariant generated code.}
    \item{Not to hamper the ability to inspect and debug generated code.}
    \item{Avoid impacting runtime with generating code.}
    \item{Ensure the user can control the feature.}
    \item{Not all of the generated loop invariants will be useful.}
\end{itemize}

\subsection{Backwards Compatibility}
\comment{
pre-existing code should not fail because of the generated invariants
code that compiles without the flag should still compile with the flag
restricts loop invariants to be precise  and strict to avoid "wrong"
}

To maintain the quality of compiler code that previously would verify without 
generated loop invariants should still verify with them.
This is important for any existing codebases in Whiley to have choice of
moving to use the generated loop invariants without needing to resolving new
errors.
If and when this occurs it is considered a bug and evidence that the implementation 
of a generated loop invariant is unsound and should be reviewed.

\subsection{Inspection and Debugging}
\comment{
Allow debugging / reviewing  of generated code
achieved by emitting compiler messages about what, where and why they are
generated
}

The ability to be able to inspect or debug the generated code is an important feature to
ensure quality of extension to Whiley.
This is in the form of compiler message describing what, where and why
the loop invariants were generated or by writing the modified program back
to disk as source code.
This allows a user to be able to inspect and review the generated loop invariants for
debugging of their code or in the process of debugging a generator.
The compromise made by this feature is that it requires coupling to other
subsystems to report back these changes.
For example to emit a compiler message appropriately it would need
to couple with the logging sub-system to enforce common log modes such as
\code{DEBUG} and \code{VERBOSE}.

\subsection{Impacting Runtime}\label{s:design-create-var}
\comment{
Whiley does not have the notion of ghost variables \\
* possible name collisions \\
* This is to be avoided \\

Does force the programmer to make ghost variables or make copies
that make sense if they were making the invariants themselves vs generated
}

To ensure the quality of generated code there should be no impact on the
runtime of the program.
The most problematic situation is attempting to refer to previous values of
a variable during or before the loop.
Whiley does not have a notion of ghost variables, variables only used for
specifications, this forces the use of additional local variables instead~\cite{whiley-origin}.
Figure~\ref{lst:vars} shows a common code example when the additional local
variables are used, in this case \code{items} variable is used to compare
against the previous value.
This forces a loop generator to either create their own ghost variables or
attempt to identify another local variable in the program that will act as the
same.
To generate the local variable the type of the copied variable is needed to be
known to mimic and a new statement directly before the loop is needed to be
added.
For example figure~\ref{lst:vars} would replace the \code{modified} variable
with \code{items} and the generated code will have an assignment just before
the while loop.
The issue of creating local variables is that it could add a runtime cost by
adding an additional copy of a potentially large data structure
and holding it in memory without being used.
The alternative to this is to restrict the loop invariant generators to check
for other variables that can work as pseudo-ghost variables.
This pattern is common in Whiley code as the lack of ghost variables require
the style of code in figure~\ref{lst:vars} to verify.
This resolves the issue of hidden local variables from the programmer
and gives them control over how they are handled.
The trade-off of not having a hidden runtime cost with restricted generators
is the most beneficial for the end-user as existing code will also benefit
and for more complex invariants the ghost variables are still required.

\begin{figure}[ht]
\begin{lstlisting}
function add_one(int[] items) -> int[]:
    i = 0
    modified = items
    //
    while i < |items|
        where all { k in 0..i | modified[i] == items[i] + 1 }
        where |modified| == |items|:
        modified = items[i] + 1
        i = i + 1
    //
    return modified
\end{lstlisting}
\caption{Example of Whiley program with \code{modified}.}
\label{lst:vars}
\end{figure}

\subsection{Usability}
\comment{
COMPILER FLAGS \\
How easy it is to control the functionality  \\
Error messages \\
No goal on time impact \\
Choice to not repeat compilation and verification
}

The command line interface and the WhileyWeb IDE are the only user interfaces
of the Whiley Compiler.
The modification of the WhileyWeb IDE was out of scope of this project as it
would only be beneficial if user studies were conducted.
Thus the only user interface that the usability needs to be maintained or
improved is the command line interface.
This includes how users can control the loop invariants generators and what
compiler feedback is required.
This is handled by exposing control of the loop invariants generators via
a compiler flag.
This is inline with how other optional features are handled in Whiley and
other standard compilers such as the GNU C compiler.

\subsection{Essential Invariants}
\comment{
It is known that all invariants generated will not be useful to proving the post-condition
(due to P-C has no input generated inv) \\

It is OK to have the minimal set of invariants
to test if it is essential requires repetitive verifications, infringes on
impact on compile time.
}

To provide some base quality of loop invariant generators that generated invariants 
can be redundant.
This means that it is acceptable that a generated invariant is not
checked that it is redundant for the verification of the loop or the function
as whole.
If the generated loop invariant were checked if they were redundant
they would need to determine what is essential either by greatly increasing
the complexity of the generators by inferring if there is another invariant
that is a stronger or weaker condition than itself.
Another method would be to attempting to find the
minimal set of invariants by testing combinations of invariants.
The trade-off of this decision is that at the cost of having some redundant
invariants that the complexity of code and time generating loop invariants is
greatly reduced.

\section{Targeted loop invariants}

Though each loop had many individualised loop invariants some invariant held a
common pattern across the loops.
From these commonly recurring invariants four of them were identified and
studied why they were applicable.
This section outlines these invariants, gives examples of where they apply and
describes the commonly observed loop structure where they occur.
with a loop design pattern \cite{pattern-lang}.

\fixme{not sure if the loop pattern stuff actually works out now}
\fixme{would loop invariant patterns be more applicable?}

\subsection{Starting bound}

The starting bound invariant is a common bounding invariant for a counting
variable in a loop.
The use of counting variables are common in Whiley due to a lack of 
general \code{for} loops that have self-contained counting variables
that are seen in languages such as Java.
The most common use case of this loop invariant is enforcing that 
a variable used to index an array is greater than 0 as shown in
figures~\ref{lst:starting-bound-sum} and \ref{lst:starting-bound-contains}.
It is obvious from inspection that the value of \code{i} is 0 at entry
of the loop and that it will increase with every iteration from the code before
and inside the loop.
This is required since the Whiley theorem prover cannot generally 
determine the value of the variable and instead relies on the programmer
providing the range, be it partially or completely specified.

\subsubsection{Loop Pattern}

The commonly thread between each instance of a starting bound invariant
is the structure before and in the loop.
Before the loop it is observed that initial value of the counting
variable is initialized or set to constant a constant value.
This is either the lower or upper bound of the range of the loop.
Inside the loop the body ensures that the counting variable is within
the range.
This is generally be achieved by incrementing or decrementing the variable
to the other boundary of the array than it started on, from lower to upper or
upper to lower bound respectfully.

\paragraph{Examples}

Below are three valid Whiley programs that contain a starting bound
invariant.
Each of these examples are operating on lists since they are verifiable
examples in the current version of Whiley.
This includes a simple iterations that use counters. Though not all
examples require the starting bound invariants to verify they still hold.


\begin{figure}[ht]
\begin{lstlisting}
int counter = I
...
while C
    where f(counter) <> I:
    ... 
    counter = f(counter)
    ...
\end{lstlisting}
    \caption{Example of a starting bound invariant for Fibonacci sequence (unverified).}
\label{lst:starting-bound-gen}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function fib(int iter) -> (int r)
requires iter >= 0
requires iter == 0 ==> r == 1
requires iter == 1 ==> r == 1
ensures  iter > 1  ==> r == fib(iter - 1) + fib(iter - 1):
    // declarations omitted
    i, a, b = iter, 1, 0
    while i >= 0
        where i <= iter && a >= 1 && b >= 0 // starting bounds
        ... // omitted
        int c = a
        a = a + c
        b = c
        i = i + 1
    //
    return a
\end{lstlisting}
    \caption{Example of a starting bound invariant for Fibonacci sequence (unverified).}
\label{lst:starting-bound-fib}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function sum(int[] items) -> (int r)
requires all { i in 0..|items| | items[i] >= 0 }:
    int i = 0
    int sum = 0
    while i < |items|
    where sum >= 0
    where i >= 0: // starting bound
        sum = sum + items[i]
        i = i + 1
    //
    return sum
\end{lstlisting}
\caption{Example of a starting bound invariant.}
\label{lst:starting-bound-sum}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function contains(int[] items, int item) -> (bool r)
ensures  r ==> some { i in 0..|items| | items[i] == item }
ensures !r ==> all  { i in 0..|items| | items[i] != item }:
    int i = 0
    while i < |items|
    where i >= 0 // starting bound
    where all { j in 0..i | items[j] != item }:
        if items[i] == item:
            return true
        i = i + 1
    //
    return false
\end{lstlisting}
\caption{Example of a starting bound invariant.}
\label{lst:starting-bound-contains}
\end{figure}

\fixme{ran out of pages? put this in appendix!}

\paragraph{Context} 

The context of the pattern is to solve the issue that the loop 
body want to keep track of where it is in the loop.
This could be to count the number of iterations or keeping track
of what element is to be processed in the next iteration.

\paragraph{Problem}

This loop pattern seeks to solve the problem of 

\paragraph{Forces}

\paragraph{Solution}

\paragraph{Resulting Context}

\todo{bunch of examples}

\subsection{Equal array length}

\todo{bunch of examples}

\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | items[i] + delta == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0 // starting bound
    where |mod| == |items| // equal array length
    where all { j in 0..i | items[j] + delta == mod[j] }:
        mod[i] = items[i] + delta
        i = i + 1
    //
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}


\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | items[i] + delta == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0 // starting bound
    where |mod| == |items| // equal array length
    where all { j in 0..i | items[j] + delta == mod[j] }:
        mod[i] = items[i] + delta
        i = i + 1
    //
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}

\subsection{Upper bound}

\todo{bunch of examples}


\begin{figure}[ht]
\begin{lstlisting}
function len(int[] items) -> (int r)
ensures r == |items|:
    int i = 0
    while i < |items|
    where i <= |items| // upper bound
    where i >= 0:
        i = i + 1
    return i
\end{lstlisting}
\caption{Example of an upper bound invariant.}
\label{lst:starting-bound-rev}
\end{figure}
 

\subsection{Array iterative assignment}

\todo{bunch of examples}

\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | (items[i] + delta) == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0
    where |items| == |mod|
    // iterative assignment
    where all { j in 0..i | mod[j] == (items[j] + delta) }:
        mod[i] = items[i] + delta
        i = i + 1
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}

\section{Techniques used to infer properties of a loop}
\comment{
Cover the individual techniques that were used in each generator \\
 - discovering loop context \\
 - determining if a variable has a simple mutation \\
 - determining if a sequence is increasing or decreasing  \\
 - decomposing loop conditions \\
 - identify usage of variables in the loop \\
 - associating a copied array back to its source \\
 - checking for self dependencies \\
}

Each loop invariant is the composition multiple techniques to generate their
invariants. This section will provide discuss the techniques, what they
accomplish and where their limitations lay.
The techniques covered are:

\begin{itemize}
    \item{Loop Context}
    \item{Determining a simple mutation}
    \item{Decomposing Loop conditions and Invariants}
    \item{Associate copied arrays to source}
\end{itemize}

\subsection{Loop Context}\label{s:loop-context}
\comment{
Write about the pre-loop stuff \\
 * how it collects data \\
 * what data it collects \\
 * why it collects \\
 * how it decides what to collect \\
 * how it differ between variables and parameters
}

\fixme{Break up and expand on this}

The loop context provides all of the techniques an understanding of the
variables before the loop.
This is used to replace the instance of the variable with its assigned value
before the loop.
This base information provides the values of local variables and parameters of
the function and tracks their values through the statements before the loop.
On a branching point in the program the context of each path is collected
separately then the intersection is taken with respect to the
parent context when the branches join.
The intersection is used so only variables that were only defined in the
branch does not leak into the rest of the context and variables defined outside
of the branch and mutated in it are updated.
In the case that an existing variable is mutated in a branch the value becomes
undetermined as it is unknown if the branch will be taken.
Figure~\ref{lst:loop-context} shows an illustration of information captured as
the context is collected though the statements before the while loop.
In particular the variable \code{limit} shows how branches are handled
and that it becomes indeterminable at the loop due to being mutated in the if
branch.

\begin{figure}[ht]
\begin{lstlisting}
function f(int count): // C = { count: <parameter }
    int[] items = [0; count] // C + { items -> [0; count] }

    int limit = 0 // C +  { limit -> 0 } 

    if g(items): // branch: C -> C`
        int f = 1 // C' + { f -> 1 }
        limit = h(items) // C' + { limit -> h(items) }
    // C` intersection C => C + { limit -> ?? }

    int i = 0 // C + { i -> 0 }

    // Final Loop context
    // C is { count -> <parameter>, items -> [0;count],
    //   limit -> ??, i -> 0 }
    while i <= limit:
        items[i] = i
        i = i + 1
\end{lstlisting}
\caption{Example of the information gathered by the loop context}
\label{lst:loop-context}
\end{figure}

\subsection{Determining a simple mutation}\label{s:simple-mut}

\fixme{Break up and expand on this}

A simple mutation is an expression that only includes addition or subtraction
of a known variable or constant.
This is to test that the expression is a monotonic expression \cite{tanton2005encyclopedia}.
Operations such as multiplication, division and function calls are disallowed
because the monotonic property of these operations are dependent on their
runtime values.
For example a multiplication between a constant and a variable,
the result of the expression may change from being an increasing expression
to decreasing after some unknown point, such as a polynomial equation.

The current design only allows a single variable to be in a simple mutation
expression.
That variable must also be the variable that is being mutated as well.
For example in figure~\ref{lst:simple-mutation} the assignment of \code{i} on
line 3 is simple since it refers to itself variable.
However, the assignment of \code{f} on line 6 is not simple as
it refers to a variable that is not \code{f}.
This limitation is due to a only needing to 
support single variable mutations for the loop invariants
that depended on this mechanism.

\begin{figure}[ht]
\begin{lstlisting}
int i = 0
int f = 0
i = i + 1 // simple
i = i + 1 - 10 + 1 + 1000 // simple
f = g(f)  // not simple
f = i + 1 // not simple
f = f * f // not simple
\end{lstlisting}
\caption{Example simple mutations}
\label{lst:simple-mutations}
\end{figure}

\subsection{Determining if a value is increasing or decreasing}\label{s:sequence-dir}

\fixme{Break up and expand on this}

From a simple mutation inside a loop it can be determined if the value is
increasing or decreasing with each iteration.
To achieve this the symbolic executable property of a simple mutation is
exploited to simulate two iterations worth of mutations.
The known variable in the mutation is set to an initial value of zero for
the first iteration and uses the result for the second.
Since the simple mutation is a linear monotonic function it is known that
the difference between each iteration will be constant.
From the result of difference between the first and second iteration the
value can be observed to increase for all iterations if it is positive or
decrease if negative. If there is no difference between the iterations then
it is considered stationary and is considered an error state.
This process is outlined in figure~\ref{math:simple-mutation}.

\begin{figure}
    $$\text{Given that } f(x) \text{ is a linear monotonic function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
    \caption{Outline of determining if a function increases or decreases with
    each application}
\label{math:simple-mutation}
\end{figure}

\subsection{Decomposing Loop conditions and Invariants}\label{s:cond-decompose}
\comment{
    Whiley semantics means all where clauses are conjunctively joined, \\
    A loop condition that is conjunctively joined can be broken into
    segments
}

\subsection{Associate length of copied arrays to source}\label{s:copied-array}
\comment{ was a array initialised with a copy from an array type or use a
generator }

The length of a new array can determine by associating the length to a source
array.
This relies on how the new array is created, for example if the array is
generated using an array generator or from copying another array it can be.
However, if the array is generated by a function it is more difficult to
determine and was out-of-scope.
When using an array generator the length of the array can be determined by
evaluating the count of the generator.
Figure~\ref{lst:simple-mutations} has an example of this for the initialisation
of \code{a}, where the length of the array is associated with the value 10.
In the case of an array copy the array size can be determined by taking the
size of the source array as they will be equal.
This is shown in figure~\ref{lst:simple-mutations} when initialising \code{b}
and \fixme{should associations be transitive? or transitive to a list of values}

This technique is used to associate ghost arrays used to assist in writing
loop invariants.

\begin{figure}[ht]
\begin{lstlisting}
int[] a = [0; 10] { |a| -> 10 }
int[] b = a { |b| -> 10, |a| -> |b| }
int[] c = f() { c -> ?? }

a = f() { |a| -> ?? }

// final association: { |b| -> 10, |a| -> ??, |c| -> ?? }
\end{lstlisting}
\caption{Examples of associated array lengths}
\label{lst:simple-mutations}
\end{figure}

% ==========================================================
\todo{Looks best to move the next sections into impl chapter}

\comment{
Biggest design decision  was at what level are the invariants going to be inferred
then where are they going to be generated
}
\section{Approaches to Loop Invariant Generation}

The principle design decision of this project was at
what point in the Whiley Compiler pipeline
to generate the loop invariants.
There are three candidate stages in the Whiley Compiler
that the input program will go through in the process of
being verified, the list is not necessarily in order of occurrence:

\begin{itemize}
    \item{Whiley Intermediate Language}
    \item{Whiley Assertion Language}
    \item{Whiley's Abstract Syntax Tree}
\end{itemize}

Each of these stages have different representations of the Whiley program and
associated information about the program itself.
In the resulting solution the design approach taken was to build upon
Whiley's abstract syntax tree.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \todo{PUT A UML DIAGRAM OF THE AST}
\end{minipage}
\caption{Example of a Whiley snippet and UML of its AST}
\label{lst:design-whiley}
\end{figure}

\subsection{Whiley Intermediate Language (WyIL)}
\comment{
possible method to create tool on WyIL

What could be achieve with this:

 * is designed to be a binary version of the code

 * WyIL goal is to make intermediate language between ALL targets of Whiley

 * AST converted into loosely connected values via integers

 * less information readily available
}

The Whiley Intermediate Language (WyIL) is a binary representation of a Whiley program
that can be easily transformed into other targets such as languages or
instruction sets \cite{wyil}.
It is a register based language with no nested expressions
that also includes blocks to group together statements such as the body of a loop.
This allows the language to keep a majority of its structure with the
exception of local variables and intermediate values becoming indistinguishable
without analysis.

The structure of internal API to query and modify WyIL code impedes a
generator's ability to match it against a loop pattern.
This is from the internal structure of a statement in WyIL where each
statement is loosely defined with op codes and blocks.
By generating the loop invariants as additional byte code the ability to
inspect the result and debug them are hampered relative to operating on the
AST.  This is because the ability to decompile from WyIL to Whiley could
be impeded which prevents the user from being able to inspect the generated
code.
WyIL can also be decompiled to a representation similar to assembly, see
figure~\ref{lst:design-wyil} for an example of Whiley code compared to its
intermediate language equivalent.
This example shows the amount of information available about the variables
in the program and their usage in the loop.
This approach was not selected due to the disconnect between loop patterns
in the programmer source code to their representation in WyIL.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyIL Code},frame=tlrb,numbers=none]{Name}
const %1 = 0
loop modifies %1
    invariant :
        const %2 = 0
        ifge %1, %2
        goto lab_0
        fail
    .lab_0
        return
    ifge %1, %0
    goto lab_1
    add %1 = %1, %0
.lab_1
return %1
\end{lstlisting}
\end{minipage}
    \caption{Example of simple Whiley snippet as WyIL}
    \label{lst:design-wyil}
\end{figure}

\subsection{Whiley Assertion Language (WyAL)}
\comment{
WyAL, what it is:

* changes would be more dramatic

* Does not have the same level of control

* hosted inside the theorem prover
}

The Whiley Assertion language (WyAL) is derived from WyIL to create
assertions for the Whiley automated theorem prover \cite{wyal}.
WyAL follows a similar syntax to regular Whiley except that the program
is a collection of boolean expressions with additional constructs such as
if branches and universal quantifiers.
No program logic or structure is held in WyAL but are kept in the source
WyIL program.

Figure~\ref{lst:design-wyal} shows an example of WyAL code generated from
the given Whiley code.
This figure shows the assertions for a simple loop invariant as well as the
assertion message which are directly displayed to the user on failure.
The main benefit of generating loop invariants at the WyAL level is the
impact of the new loop invariants are contained to only the verification
process and prevents a generator author from breaking a design consideration,
such as not creating variables, as the Whiley code is immutable by this point.
However, since the lack of program logic in WyAL requires the use of a WyIL program
as backing the same issues with WyIL are present with working on WyAL.
This includes the difficultly to correlate between the high-level structure
in a Whiley program to the resulting WyIL code.

\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyAL Code},frame=tlrb,numbers=none,breaklines=true]{Name}
function count(int[] ls) -> (int n)

define count_loopinv_6(int i) is:
  i >= 0


assert "loop invariant does not hold on entry":
  forall(int i$0):
    if:
      i$0 == 0
    then:
      count_loopinv_6(i$0)


assert "loop invariant not restored":
  forall(int i$1, int i, int i$2):
    if:
      i == 0
      count_loopinv_6(i$1)
      i$1 > 0
      i$2 == (i$1 + 1)
    then:
      count_loopinv_6(i$2)
\end{lstlisting}
\end{minipage}
    \caption{Example of simple Whiley snippet as WyAL}
    \label{lst:design-wyal}
\end{figure}

\subsection{Whiley Abstract Syntax Tree}
\comment{
    Whiley files \\
    * Closest to programmer code \\
    * most information in the most related form \\
}

The Whiley abstract syntax tree (AST) is the closest representation to
the source code.
This also includes the most information available, which includes detailed
types, variable names and expression trees \cite{whiley-origin}.
The AST is broken into three types of: top level declarations of types,
methods and functions ; statements blocks for individual statements
such as assignments or structures such as if statements; and, expressions
that include the usage of variables, function calls and constants.
There is some overlap between statements and expressions in the AST,
such as function calls are both statements and expressions given that they
return a value.
This gives the invariant generator to be able to identify loop patterns in the
structure.

However, the amount of information comes as at a cost of being able to parse
it and discover relevant information.
The structure of internal API of the Whiley AST forces a recursive decent
approach, much like the other internal languages in the compiler.
However, the AST is the richest in terms of number of types of nodes
in the AST needed to be supported to parse properly with
statement trees, expression trees and top-level declarations of methods and
types.
The cost of supporting all of these different nodes in the AST is
repeated code handling traversal and needing to handle a large range
of cases to parse a statement.
These costs are acceptable since it allows for generators to be
the most expressive and enable other design constraints of
debugging and inspection.

\section{Architecture of Loop Invariant Generators}
\comment{
    ALL ONE BLOB! vs strategy + a common set of information \\
    Explain how each generator is distinct code \\
    UML of strategy pattern \\
    the utility package
}

Another critical design decision was the architecture of how loop invariant
generators operate on the AST.
The architecture needs to fit with other similar static analysis checks
implemented, such as the definite assignment and type system, which all
traverse the AST once.
For this solution two architectural options are available to solve this issue:

\begin{itemize}
    \item{Monolithic, traversing the AST once and apply all generators at once,}
    \item{Multiple sweeps, traversing the AST once but repeat loops multiple times for each generator}
\end{itemize}

The architecture chosen for the resulting solution is  traversing the AST once
but repeating on loops so that each generator could inspect the loop.

\subsection{Monolithic Single Sweep}
\comment{
What would a monolithic look like \\
single pass \\
how would it impact metrics such as maintainability \\
how would it impact performance \\
}

A monolithic single sweep of the AST will only visit each
node in the AST once to generate the loop invariants.
This requires all loop invariant generators to be operating
during the pass or have all of their required information collected
in the single pass.
This minimizes the operational cost of traversing the loop body
multiple times at the cost of maintaining a monolithic loop invariant generator.
However, with the interweaving of multiple generators the maintenance of the
monolithic structure becomes issue prone.
This option was not implemented as the maintenance cost out weighed any
runtime performance benefits gained.


\todo{include UML of what the pipeline would look like with this arch}

\subsection{Multiple Sweeps with the Strategy Pattern}
\comment{
What would a monolithic look like \\
* multi-pass, no entire file multiple-times but same section \\
* how would it impact metrics such as maintainability \\
* how would it impact performance
}

Multiple sweeps of loops in the AST with a different strategy for each sweep
will only visit most nodes once but loop bodies.
This gives loop generators complete control over how they traverse the loop
body's AST at the cost of traversing the loop multiple times.
The additional benefit of each generator being separate is the maintenance cost
of adding a new generator or modifying an existing generator is greatly reduced
relative to a monolithic approach as each generator is not intertwined with
each other.
This option was selected as the cost of maintenance was significantly less
than a monolithic solution.
Another factor is that the architecture could still progress towards
a partial monolithic-strategy based architecture if the performance hit
of traversing loops becomes a bottleneck.
This can be achieved by finding patterns of what information generators are
seeking and provide an interface where that information is computed once for
all generators that require it and keep the traversal interface for unique generators.

\todo{include UML of what the pipeline would look like with this arch}
