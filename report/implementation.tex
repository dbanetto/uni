\chapter{Implementation}\label{C:impl}
\comment{
The aim here is to explain the technical aspects of the project.
The challenge is to ensure the text is clear and understandable.
This is not easy, as ideas and concepts involved are often complex in nature.
Nevertheless, if an examiners cannot understand how the implementation works,
he/she cannot award marks for it.
If this happens, the student is fault for poor communication. \\

Remember: \\
nothing is so complicated that it cannot be clearly explained.
Classic pitfalls include: \\
    * long convoluted sentences, \\
    * use of long words, \\
    * too much time spent discussing irrelevant details, \\
    * poor organisation of sections, subsections and paragraphs, \\
    * and too few diagrams or examples.
}


\todo{Looks best to move the next sections into impl chapter}

\comment{
	Biggest design decision  was at what level are the invariants going to be inferred
	then where are they going to be generated
}
\section{Approaches to Loop Invariant Generation}

The principle design decision of this project was at
what point in the Whiley Compiler pipeline
to generate the loop invariants.
There are three candidate stages in the Whiley Compiler
that the input program will go through in the process of
being verified, the list is not necessarily in order of occurrence:

\begin{itemize}
	\item{Whiley Intermediate Language}
	\item{Whiley Assertion Language}
	\item{Whiley's Abstract Syntax Tree}
\end{itemize}

Each of these stages have different representations of the Whiley program and
associated information about the program itself.
In the resulting solution the design approach taken was to build upon
Whiley's abstract syntax tree.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|:
  i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\todo{PUT A UML DIAGRAM OF THE AST}
\end{minipage}
\caption{Example of a Whiley snippet and UML of its AST}
\label{lst:design-whiley}
\end{figure}

\subsection{Whiley Intermediate Language (WyIL)}
\comment{
	possible method to create tool on WyIL
	
	What could be achieve with this:
	
	* is designed to be a binary version of the code
	
	* WyIL goal is to make intermediate language between ALL targets of Whiley
	
	* AST converted into loosely connected values via integers
	
	* less information readily available
}

The Whiley Intermediate Language (WyIL) is a binary representation of a Whiley program
that can be easily transformed into other targets such as languages or
instruction sets \cite{wyil}.
It is a register based language with no nested expressions
that also includes blocks to group together statements such as the body of a loop.
This allows the language to keep a majority of its structure with the
exception of local variables and intermediate values becoming indistinguishable
without analysis.

The structure of internal API to query and modify WyIL code impedes a
generator's ability to match it against a loop pattern.
This is from the internal structure of a statement in WyIL where each
statement is loosely defined with op codes and blocks.
By generating the loop invariants as additional byte code the ability to
inspect the result and debug them are hampered relative to operating on the
AST.  This is because the ability to decompile from WyIL to Whiley could
be impeded which prevents the user from being able to inspect the generated
code.
WyIL can also be decompiled to a representation similar to assembly, see
figure~\ref{lst:design-wyil} for an example of Whiley code compared to its
intermediate language equivalent.
This example shows the amount of information available about the variables
in the program and their usage in the loop.
This approach was not selected due to the disconnect between loop patterns
in the programmer source code to their representation in WyIL.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
where i >= 0:
  i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyIL Code},frame=tlrb,numbers=none]{Name}
const %1 = 0
loop modifies %1
invariant :
const %2 = 0
ifge %1, %2
goto lab_0
fail
.lab_0
return
ifge %1, %0
goto lab_1
add %1 = %1, %0
.lab_1
return %1
\end{lstlisting}
\end{minipage}
\caption{Example of simple Whiley snippet as WyIL}
\label{lst:design-wyil}
\end{figure}

\subsection{Whiley Assertion Language (WyAL)}
\comment{
	WyAL, what it is:
	
	* changes would be more dramatic
	
	* Does not have the same level of control
	
	* hosted inside the theorem prover
}

The Whiley Assertion language (WyAL) is derived from WyIL to create
assertions for the Whiley automated theorem prover \cite{wyal}.
WyAL follows a similar syntax to regular Whiley except that the program
is a collection of boolean expressions with additional constructs such as
if branches and universal quantifiers.
No program logic or structure is held in WyAL but are kept in the source
WyIL program.

Figure~\ref{lst:design-wyal} shows an example of WyAL code generated from
the given Whiley code.
This figure shows the assertions for a simple loop invariant as well as the
assertion message which are directly displayed to the user on failure.
The main benefit of generating loop invariants at the WyAL level is the
impact of the new loop invariants are contained to only the verification
process and prevents a generator author from breaking a design consideration,
such as not creating variables, as the Whiley code is immutable by this point.
However, since the lack of program logic in WyAL requires the use of a WyIL program
as backing the same issues with WyIL are present with working on WyAL.
This includes the difficultly to correlate between the high-level structure
in a Whiley program to the resulting WyIL code.

\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
where i >= 0:
  i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyAL Code},frame=tlrb,numbers=none,breaklines=true]{Name}
function count(int[] ls) -> (int n)

define count_loopinv_6(int i) is:
  i >= 0
      
assert "loop invariant does not hold on entry":
    forall(int i$0):
      if:
        i$0 == 0
      then:
        count_loopinv_6(i$0)

assert "loop invariant not restored":
  forall(int i$1, int i, int i$2):
    if:
      i == 0
      count_loopinv_6(i$1)
      i$1 > 0
      i$2 == (i$1 + 1)
    then:
      count_loopinv_6(i$2)
\end{lstlisting}
\end{minipage}
\caption{Example of simple Whiley snippet as WyAL}
\label{lst:design-wyal}
\end{figure}

\subsection{Whiley Abstract Syntax Tree}
\comment{
	Whiley files \\
	* Closest to programmer code \\
	* most information in the most related form \\
}

The Whiley abstract syntax tree (AST) is the closest representation to
the source code.
This also includes the most information available, which includes detailed
types, variable names and expression trees \cite{whiley-origin}.
The AST is broken into three types of: top level declarations of types,
methods and functions ; statements blocks for individual statements
such as assignments or structures such as if statements; and, expressions
that include the usage of variables, function calls and constants.
There is some overlap between statements and expressions in the AST,
such as function calls are both statements and expressions given that they
return a value.
This gives the invariant generator to be able to identify loop patterns in the
structure.

However, the amount of information comes as at a cost of being able to parse
it and discover relevant information.
The structure of internal API of the Whiley AST forces a recursive decent
approach, much like the other internal languages in the compiler.
However, the AST is the richest in terms of number of types of nodes
in the AST needed to be supported to parse properly with
statement trees, expression trees and top-level declarations of methods and
types.
The cost of supporting all of these different nodes in the AST is
repeated code handling traversal and needing to handle a large range
of cases to parse a statement.
These costs are acceptable since it allows for generators to be
the most expressive and enable other design constraints of
debugging and inspection.

\section{Architecture of Loop Invariant Generators}
\comment{
	ALL ONE BLOB! vs strategy + a common set of information \\
	Explain how each generator is distinct code \\
	UML of strategy pattern \\
	the utility package
}

Another critical design decision was the architecture of how loop invariant
generators operate on the AST.
The architecture needs to fit with other similar static analysis checks
implemented, such as the definite assignment and type system, which all
traverse the AST once.
For this solution two architectural options are available to solve this issue:

\begin{itemize}
	\item{Monolithic, traversing the AST once and apply all generators at once,}
	\item{Multiple sweeps, traversing the AST once but repeat loops multiple times for each generator}
\end{itemize}

The architecture chosen for the resulting solution is  traversing the AST once
but repeating on loops so that each generator could inspect the loop.

\subsection{Monolithic Single Sweep}
\comment{
	What would a monolithic look like \\
	single pass \\
	how would it impact metrics such as maintainability \\
	how would it impact performance \\
}

A monolithic single sweep of the AST will only visit each
node in the AST once to generate the loop invariants.
This requires all loop invariant generators to be operating
during the pass or have all of their required information collected
in the single pass.
This minimizes the operational cost of traversing the loop body
multiple times at the cost of maintaining a monolithic loop invariant generator.
However, with the interweaving of multiple generators the maintenance of the
monolithic structure becomes issue prone.
This option was not implemented as the maintenance cost out weighed any
runtime performance benefits gained.


\todo{include UML of what the pipeline would look like with this arch}

\subsection{Multiple Sweeps with the Strategy Pattern}
\comment{
	What would a monolithic look like \\
	* multi-pass, no entire file multiple-times but same section \\
	* how would it impact metrics such as maintainability \\
	* how would it impact performance
}

Multiple sweeps of loops in the AST with a different strategy for each sweep
will only visit most nodes once but loop bodies.
This gives loop generators complete control over how they traverse the loop
body's AST at the cost of traversing the loop multiple times.
The additional benefit of each generator being separate is the maintenance cost
of adding a new generator or modifying an existing generator is greatly reduced
relative to a monolithic approach as each generator is not intertwined with
each other.
This option was selected as the cost of maintenance was significantly less
than a monolithic solution.
Another factor is that the architecture could still progress towards
a partial monolithic-strategy based architecture if the performance hit
of traversing loops becomes a bottleneck.
This can be achieved by finding patterns of what information generators are
seeking and provide an interface where that information is computed once for
all generators that require it and keep the traversal interface for unique generators.

\todo{include UML of what the pipeline would look like with this arch}

\todo{re-do start of this}
The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiley-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another.
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.

\section{Starting Value Invariant}
\comment{
finds entry value \\
creates invariants from composing things \\
has the loop pattern of \\
int $i$ = $X$ \\
while $C$: \\
    $P_1$ \\
    $i = i (+|-) N$ \\
    $P_2$
}

\ref{s:sequence-dir} \ref{s:simple-mut} \ref{s:loop-context}

A common pattern observed in 

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.
The loop invariant inferred is a bounding invariant.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

With the identification of the variable with a simple mutation and knowing
if it decreases or increases each iteration an invariant can be made.
This is in the form of the variable on the left with either a less than or
equal to ($\leq$) or greater than or equal to ($\geq$) to the initial value on the
right.
In figure~\ref{lst:whiley-start} the variable \code{i} is clearly increasing
with each iteration due to line 7 and the inferred invariant, on line 5, is
obvious from the context.

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}

\section{Equal Length of Copied Arrays Invariant}
% array length
\comment{
    * finds associated arrays \\
    * checks to make sure source is not modified \\
    * asserts their length is the same \\

pattern: \\

$x = ( a | [X;|a|] )$ \\
while C: \\
    $P$ - not includes $x = X$, $a = Y$\\
}

\todo{remove techniques to design}

From a common pattern of making a copy of arrays or generating another array
with an equal length an invariant can be inferred.
This loop pattern is found when applying a function that changes the type of
the element or the user does not wish to update the original array.
Figure~\ref{lst:whiley-length} shows a simple example of applying a function
\code{apply ()} to each element of an array.
Generally the user would also need to provide an invariant that both arrays
have the same length to prevent possible out-of-range errors or prove a
post-condition.
The loop invariant inferred is a bounding invariant.

\todo{ref to design instead of assuming it is here}


With this invariant it is detected that an array is declared with the same
length as another array.
This is achieved by inspecting the AST of the program
using forward propagation to find assignments to arrays.
Due to Whiley's copy semantics it is known that the assignment will result
in a clone of array and are distinct \cite{whiley-origin} \cite{whiley-arrays}.
This can also be achieved by finding a use of the array
generator syntax, see line 4 of figure~\ref{lst:whiley-length}.

The arrays that are shown to be equal in length to another array are
check to ensure the array size does not change.
This is achieved by checking that there is no assignments to either
of the two arrays involved either before entering the loop or
anyway inside the loop.
If there was an assignment it is no longer a simple to infer if
the arrays are equal size and an invariant is not generated.
However, an assignment to an element of the array is passable since it
is known that it won't change the array size just the contents.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    float[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        copy[i] = apply(items[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

From this information an invariant is known and can be generated.
Given the source array and the array of known equal length the
invariant of the lengths are equal.
See figure~\ref{lst:whiley-length} line 5 for the invariant generated
from the example code.

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}

\section{Loop Condition Ageing Invariant}

\comment{
Finds simple mutations \\
Figures out actually how much the value changes every iteration
(is slight change on finding sequence direction, just stricter) \\
checks to ensure that the variable is apart of the termination condition of the
loop \\
Allow mutations of +1 or -1 each iteration\\

pattern: \\

$i = N$ \\
while $C$ \\
    $P_1$ \\
    $i = i (+|-) (1|-1)$ \\
    $P_2$ \\
}


\subsection{Formal Definition}

\subsection{Limitations}

\section{Iterative Array Assignment Invariant}

\comment{
Finds arrays that are being set \\
Ensures the assignments are not self-dependent \\
Identifies the index variable and is simple mutations \\
Ensure index start of mutation on array, like starting bound \\
figures out sequence direction of index, ascending or descending the array \\
use index as the upper or lower bound \\
determines range of the mutation \\

pattern: \\

$i = N$ \\
$a = [ .. ]$ \\
while $C$: \\
    $a[i] = f(i)$ \\
    $i = i (+|-) (1|-1)$ \\

creates $all { \_i in C .. i | a[\_i] == f(\_i) }$
}

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}
