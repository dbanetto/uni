\chapter{Design}\label{C:design}
\comment{
The aim here is to identify the key trade-offs in any design work you have undertaken.
When solving a complex problem, there are normally many different
approaches one can take — each with its own advantages and disadvantages.
It is expected that students will have initially considered a range of different solutions,
and will then have narrowed these down. The reasons why a particular approach was
discounted should be documented here.


Remember:
Appropriate design notation (e.g. UML diagrams) can be very helpful in conveying different aspects of a design.
It is vital that your design not be carried out in a vacuum.
Your design should be motivated very clearly by your goals and specifications.
Make sure that it is clear why you took the decisions that you did.
Do not give the impression that you settled on a design because it “felt right”
or that you tinkered around until you found something that worked.

Should cover: \\
 * techniques of loop invariant generation, \\
 * problem analysis \\
 * express the requirements of the solution \\
}

% intro to problem, what is the design space for this issue
%

\fixme{Update to include techniques are here, architectures in impl}

This chapter will discuss the requirements and Considerations taken to design the implementation
of this project.
These considerations are derived by the project requirements
and guided by improving or retaining the same level of
usability of the Whiley Compiler for a Whiley developer and a maintainer of the
compiler fixing or updating the modified compiler.
It will also discuss the internal design decisions of
where to place the loop invariants generators in the
current architecture of the Whiley Compiler.
This includes where the generated loop invariants are found and
how they are inserted into the program.
The final design decision discussed is how the multiple generators are managed.

\section{Requirements}
\comment{
    should cover the functional and non-functional requirements
}

The requirements of the project were derived from the project outline (see
Appendix~\ref{A:proj-outline} for the full original text).

\todo{expand on the problem}
\todo{make requirements eat the considerations section}

\section{Considerations}
\comment{
These are designs for the project and the changes and impacts on the Whiley
Language and compiler
}

Throughout the design of the overall architecture and each individual loop invariant
generator some design considerations were kept in mind.
\begin{itemize}
    \item{Backward creditability with non-loop invariant generated code.}
    \item{Not to hamper the ability to inspect and debug generated code.}
    \item{Avoid creating new local variables when generating code.}
    \item{Ensure the user can control the feature.}
    \item{Not all of the generated loop invariants will be useful.}
\end{itemize}

\subsection{Backwards Compatibility}
\comment{
pre-existing code should not fail because of the generated invariants
code that compiles without the flag should still compile with the flag
restricts loop invariants to be precise  and strict to avoid "wrong"
}

A design consideration for this project was that existing code that compiled
and verify without the loop invariant generator should still compile and verify
with it.
This consideration limits the generated loop invariants from creating
invariants that would not be supported by the program during verification.
Figure~\ref{lst:backwards-compat} shows an example of a potential loop
invariant generator that would cause previously working code to fail.
\todo{explain the example}
When this occurs it is considered a bug and evidence that the implementation or
the design of the generated loop invariant is unsound and should be reviewed.

\begin{figure}[ht]
\begin{lstlisting}
// TODO: Make an example of where a generated invariant would make the code
// fail
\end{lstlisting}
    \label{lst:backwards-compat}
    \caption{Example of a Whiley program with generated loop invariants that will
    make it fail to verify.}
\end{figure}

However, this consideration is not reflexive.
This implies that it does not ensure that a program that verifies with
generated loop invariants must still verify without them.
This design issue is considered as it is important that a user could
switch to using the generated loop invariants without suddenly having
their program failing to verify.


\subsection{Inspection and Debugging}
\comment{
Allow debugging / reviewing  of generated code
achieved by emitting compiler messages about what, where and why they are
generated
}

The ability to be able to inspect the generated code is an important feature to
design into the solution.
This could come in the form of compiler message describing what, where and why
the loop invariants were generated or by writing the modified program back
to disk as source code.
This allows a user to be able to inspect and review the generated loop invariants for
debugging of their code or in the process of debugging a generator.
The compromise made by this feature is that it requires coupling to other
subsystems to report back these changes.
For example to emit a compiler message appropriately it would need
to couple with the logging sub-system to enforce common log modes such as
\code{DEBUG} and \code{VERBOSE}.

\subsection{Creating Variables}\label{s:design-create-var}
\comment{
Whiley does not have the notion of ghost variables \\
* possible name collisions \\
* This is to be avoided \\

Does force the programmer to make ghost variables or make copies
that make sense if they were making the invariants themselves vs generated
}

The design consideration of creating variables that only used in specifications
were made for each generator.
Whiley does not have a notion of ghost variables, variables only used for
specifications, this forces the use of additional local variables instead~\cite{whiley-origin}.
Figure~\ref{lst:vars} shows a common code example when the additional local
variables are used, in this case \code{items} variable is used to compare
against the previous value.
This forces a loop generator to either create their own ghost variables or
attempt to identify another local variable in the program that will act as the
same.
To generate the local variable the type of the copied variable is needed to be
known to mimic and a new statement directly before the loop is needed to be
added.
For example figure~\ref{lst:vars} would replace the \code{modified} variable
with \code{items} and the generated code will have an assignment just before
the while loop.
The issue of creating local variables is that it could add a runtime cost by
adding an additional copy of a potentially large data structure
and holding it in memory without being used.
The alternative to this is to restrict the loop invariant generators to check
for other variables that can work as pseudo-ghost variables.
This pattern is common in Whiley code as the lack of ghost variables require
the style of code in figure~\ref{lst:vars} to verify.
This resolves the issue of hidden local variables from the programmer
and gives them control over how they are handled.
The trade-off of not having a hidden runtime cost with restricted generators
is the most beneficial for the end-user as existing code will also benefit
and for more complex invariants the ghost variables are still required.

\begin{figure}[ht]
\begin{lstlisting}
function add\_one(int[] items) -> int[]:
    i = 0
    modified = items
    //
    while i < |items|
        where all { k in 0..i | modified[i] == items[i] + 1 }
        where |modified| == |items|:
        modified = items[i] + 1
        i = i + 1
    //
    return modified
\end{lstlisting}
\label{lst:vars}
\caption{Example of Whiley program with \code{modified}.}
\end{figure}

\subsection{Usability}
\comment{
COMPILER FLAGS \\
How easy it is to control the functionality  \\
Error messages \\
No goal on time impact \\
Choice to not repeat compilation and verification
}

How users can utilise the loop invariants generators were a
consideration to the design of the solution.
This is handled but following the current design principles of the
Whiley compiler as exposing the loop invariant generator as a compiler
flag such as the verification flag.


\subsection{Essential Invariants}
\comment{
It is known that all invariants generated will not be useful to proving the post-condition
(due to P-C has no input generated inv) \\

It is OK to have the minimal set of invariants
to test if it is essential requires repetitive verifications, infringes on
impact on compile time.
}

During the design of this solution it is known that not all generated
invariants will be essential invariants.
This implies that not all of the generated loop invariants will be useful
in proving the post-condition of the loop's function.
If only the essential invariants where generated the solution would need
to determine what is essential either by increasing the complexity of the
generators by inferring the invariants from the post-condition or by
attempting to minimize the generated loop invariants by testing combinations
of invariants.
The trade-off of this decision is that at the cost of having some non-essential
invariants that the complexity of code and time generating loop invariants is
greatly reduced.

\section{Techniques to Identify Invariants}
\comment{
Cover the individual techniques that were used in each generator \\
 - discovering loop context \\
 - determining if a variable has a simple mutation \\
 - determining if a sequence is increasing or decreasing  \\
 - decomposing loop conditions \\
 - identify usage of variables in the loop \\
 - associating a copied array back to its source \\
 - checking for self dependencies \\
}

Each loop invariant is the composition multiple techniques to generate their
invariants. This section will provide discuss the techniques, what they
accomplish and where their limitations lay.
The techniques covered are:

\begin{itemize}
    \item{Loop Context}
    \item{Determining a simple mutation}
    \item{Decomposing Loop conditions and Invariants}
    \item{Identify dependencies on itself for mutations}
    \item{Identify variables used in loop}
    \item{Associate copied arrays to source}
\end{itemize}

\subsection{Loop Context}\label{s:loop-context}
\comment{
Write about the pre-loop stuff \\
 * how it collects data \\
 * what data it collects \\
 * why it collects \\
 * how it decides what to collect \\
 * how it differ between variables and parameters
}

\todo{Explain how the loop context stuff finds suitable variables}

\subsection{Determining a simple mutation}\label{s:simple-mut}

\todo{update with lattice}

The definition of a simple mutation is restricted to an expression that only
includes addition and subtraction of constant values and the variable in question.
The mutation must be certain with each iteration so the variable must not be
modified inside branching statements such as \code{if} blocks or nested loops.
Since the mutation has to be simple it restricts them to linear monotonic
functions that is either strictly increasing or decreasing the variable with each iteration.
This is to keep the loop pattern simple and deterministic of knowing if the
mutation is increases or decreases the variable with each iteration.
An expression is checked if it is a simple mutation through static analysis of
the AST.

\subsection{Determining if a value is increasing or decreasing}\label{s:sequence-dir}

The increase or decreasing nature of the simple mutation it is determined by
executing the expression. An outline of the mathematical process is outlined
in figure~\ref{math:simple-mutation}, the expression is denoted with $f(x)$.
The equations show how the difference between applying the function
twice and once on a base value is used to determine if the function
increases or decreases.
In the case that the expression is stationary the variable will not variate
between iterations and left alone.

\begin{figure}
    $$\text{Given that } f(x) \text{ is a linear function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
\label{math:simple-mutation}
    \caption{Logic of determining if a function increases or decreases with
    each application}
\end{figure}

\subsection{Decomposing Loop conditions and Invariants}\label{s:cond-decompose}

\comment{
    Whiley semantics means all where clauses are conjunctively joined, \\
    A loop condition that is conjunctively joined can be broken into
    segments
}

\subsection{Identify dependencies if variables depends on itself}\label{s:self-deps}

\comment{ is the variable in the assignment ? }

\subsection{Identify variables used in loop}\label{s:loop-vars}

\comment{ is the variable in the loop ? }

\subsection{Associate copied arrays to source}\label{s:copied-array}

\comment{ was a array initialised with a copy from an array type or use a
generator }

% ==========================================================
\todo{Looks best to move the next sections into impl chapter}

\comment{
Biggest design decision  was at what level are the invariants going to be inferred
then where are they going to be generated
}
\section{Approaches to Loop Invariant Generation}

The principle design decision of this project was at
what point in the Whiley Compiler pipeline
to generate the loop invariants.
There are three candidate stages in the Whiley Compiler
that the input program will go through in the process of
being verified, the list is not necessarily in order of occurrence:

\begin{itemize}
    \item{Whiley Intermediate Language}
    \item{Whiley Assertion Language}
    \item{Whiley's Abstract Syntax Tree}
\end{itemize}

Each of these stages have different representations of the Whiley program and
associated information about the program itself.
In the resulting solution the design approach taken was to build upon
Whiley's abstract syntax tree.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \todo{PUT A UML DIAGRAM OF THE AST}
\end{minipage}
\label{lst:design-whiley}
\caption{Example of a Whiley snippet and UML of its AST}
\end{figure}

\subsection{Whiley Intermediate Language (WyIL)}
\comment{
possible method to create tool on WyIL

What could be achieve with this:

 * is designed to be a binary version of the code

 * WyIL goal is to make intermediate language between ALL targets of Whiley

 * AST converted into loosely connected values via integers

 * less information readily available
}

The Whiley Intermediate Language (WyIL) is a binary representation of a Whiley program
that can be easily transformed into other targets such as languages or
instruction sets \cite{wyil}.
It is a register based language with no nested expressions
that also includes blocks to group together statements such as the body of a loop.
This allows the language to keep a majority of its structure with the
exception of local variables and intermediate values becoming indistinguishable
without analysis.

The structure of internal API to query and modify WyIL code impedes a
generator's ability to match it against a loop pattern.
This is from the internal structure of a statement in WyIL where each
statement is loosely defined with op codes and blocks.
By generating the loop invariants as additional byte code the ability to
inspect the result and debug them are hampered relative to operating on the
AST.  This is because the ability to decompile from WyIL to Whiley could
be impeded which prevents the user from being able to inspect the generated
code.
WyIL can also be decompiled to a representation similar to assembly, see
figure~\ref{lst:design-wyil} for an example of Whiley code compared to its
intermediate language equivalent.
This example shows the amount of information available about the variables
in the program and their usage in the loop.
This approach was not selected due to the disconnect between loop patterns
in the programmer source code to their representation in WyIL.


\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyIL Code},frame=tlrb,numbers=none]{Name}
const %1 = 0
loop modifies %1
    invariant :
        const %2 = 0
        ifge %1, %2
        goto lab_0
        fail
    .lab_0
        return
    ifge %1, %0
    goto lab_1
    add %1 = %1, %0
.lab_1
return %1
\end{lstlisting}
\end{minipage}
    \label{lst:design-wyil}
    \caption{Example of simple Whiley snippet as WyIL}
\end{figure}

\subsection{Whiley Assertion Language (WyAL)}
\comment{
WyAL, what it is:

* changes would be more dramatic

* Does not have the same level of control

* hosted inside the theorem prover
}

The Whiley Assertion language (WyAL) is derived from WyIL to create
assertions for the Whiley automated theorem prover \cite{wyal}.
WyAL follows a similar syntax to regular Whiley except that the program
is a collection of boolean expressions with additional constructs such as
if branches and universal quantifiers.
No program logic or structure is held in WyAL but are kept in the source
WyIL program.

Figure~\ref{lst:design-wyal} shows an example of WyAL code generated from
the given Whiley code.
This figure shows the assertions for a simple loop invariant as well as the
assertion message which are directly displayed to the user on failure.
The main benefit of generating loop invariants at the WyAL level is the
impact of the new loop invariants are contained to only the verification
process and prevents a generator author from breaking a design consideration,
such as not creating variables, as the Whiley code is immutable by this point.
However, since the lack of program logic in WyAL requires the use of a WyIL program
as backing the same issues with WyIL are present with working on WyAL.
This includes the difficultly to correlate between the high-level structure
in a Whiley program to the resulting WyIL code.

\begin{figure}
\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={Whiley Code},frame=tlrb,numbers=none]{Name}
i = 0
while i < |items|
    where i >= 0:
    i = i + 1
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption={WyAL Code},frame=tlrb,numbers=none,breaklines=true]{Name}
function count(int[] ls) -> (int n)

define count_loopinv_6(int i) is:
  i >= 0


assert "loop invariant does not hold on entry":
  forall(int i$0):
    if:
      i$0 == 0
    then:
      count_loopinv_6(i$0)


assert "loop invariant not restored":
  forall(int i$1, int i, int i$2):
    if:
      i == 0
      count_loopinv_6(i$1)
      i$1 > 0
      i$2 == (i$1 + 1)
    then:
      count_loopinv_6(i$2)
\end{lstlisting}
\end{minipage}
    \label{lst:design-wyal}
    \caption{Example of simple Whiley snippet as WyAL}
\end{figure}

\subsection{Whiley Abstract Syntax Tree}
\comment{
    Whiley files \\
    * Closest to programmer code \\
    * most information in the most related form \\
}

The Whiley abstract syntax tree (AST) is the closest representation to
the source code.
This also includes the most information available, which includes detailed
types, variable names and expression trees \cite{whiley-origin}.
The AST is broken into three types of: top level declarations of types,
methods and functions ; statements blocks for individual statements
such as assignments or structures such as if statements; and, expressions
that include the usage of variables, function calls and constants.
There is some overlap between statements and expressions in the AST,
such as function calls are both statements and expressions given that they
return a value.
This gives the invariant generator to be able to identify loop patterns in the
structure.

However, the amount of information comes as at a cost of being able to parse
it and discover relevant information.
The structure of internal API of the Whiley AST forces a recursive decent
approach, much like the other internal languages in the compiler.
However, the AST is the richest in terms of number of types of nodes
in the AST needed to be supported to parse properly with
statement trees, expression trees and top-level declarations of methods and
types.
The cost of supporting all of these different nodes in the AST is
repeated code handling traversal and needing to handle a large range
of cases to parse a statement.
These costs are acceptable since it allows for generators to be
the most expressive and enable other design constraints of
debugging and inspection.

\section{Architecture of Loop Invariant Generators}
\comment{
    ALL ONE BLOB! vs strategy + a common set of information \\
    Explain how each generator is distinct code \\
    UML of strategy pattern \\
    the utility package
}

Another critical design decision was the architecture of how loop invariant
generators operate on the AST.
The architecture needs to fit with other similar static analysis checks
implemented, such as the definite assignment and type system, which all
traverse the AST once.
For this solution two architectural options are available to solve this issue:

\begin{itemize}
    \item{Monolithic, traversing the AST once and apply all generators at once,}
    \item{Multiple sweeps, traversing the AST once but repeat loops multiple times for each generator}
\end{itemize}

The architecture chosen for the resulting solution is  traversing the AST once
but repeating on loops so that each generator could inspect the loop.

\subsection{Monolithic Single Sweep}
\comment{
What would a monolithic look like \\
single pass \\
how would it impact metrics such as maintainability \\
how would it impact performance \\
}

A monolithic single sweep of the AST will only visit each
node in the AST once to generate the loop invariants.
This requires all loop invariant generators to be operating
during the pass or have all of their required information collected
in the single pass.
This minimizes the operational cost of traversing the loop body
multiple times at the cost of maintaining a monolithic loop invariant generator.
However, with the interweaving of multiple generators the maintenance of the
monolithic structure becomes issue prone.
This option was not implemented as the maintenance cost out weighed any
runtime performance benefits gained.


\todo{include UML of what the pipeline would look like with this arch}

\subsection{Multiple Sweeps with the Strategy Pattern}
\comment{
What would a monolithic look like \\
* multi-pass, no entire file multiple-times but same section \\
* how would it impact metrics such as maintainability \\
* how would it impact performance
}

Multiple sweeps of loops in the AST with a different strategy for each sweep
will only visit most nodes once but loop bodies.
This gives loop generators complete control over how they traverse the loop
body's AST at the cost of traversing the loop multiple times.
The additional benefit of each generator being separate is the maintenance cost
of adding a new generator or modifying an existing generator is greatly reduced
relative to a monolithic approach as each generator is not intertwined with
each other.
This option was selected as the cost of maintenance was significantly less
than a monolithic solution.
Another factor is that the architecture could still progress towards
a partial monolithic-strategy based architecture if the performance hit
of traversing loops becomes a bottleneck.
This can be achieved by finding patterns of what information generators are
seeking and provide an interface where that information is computed once for
all generators that require it and keep the traversal interface for unique generators.

\todo{include UML of what the pipeline would look like with this arch}
