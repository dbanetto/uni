\documentclass[11pt, a4paper, twoside, openright]{report}

\usepackage{float} % lets you have non-floating floats

\usepackage{listings}
\usepackage[usenames, dvipsnames]{color}
\usepackage{url} % for typesetting urls
\usepackage{mathtools}
% \usepackage{pdfpages} % for including PDF's into the document
\usepackage[parfill]{parskip}

%  We don't want figures to float so we define
%
\newfloat{fig}{thp}{lof}[chapter]
\floatname{fig}{Figure}

\definecolor{grey}{rgb}{0.95,0.95,0.95}

\lstset{%
    backgroundcolor=\color{grey},
    frame=single,
    numbers=left
}

%% These are standard LaTeX definitions for the document
%%
\title{Generating simple loop invariants for Whiley}
\author{David Barnett}

%% This file can be used for creating a wide range of reports
%%  across various Schools
%%
%% Set up some things, mostly for the front page, for your specific document
%
% Current options are:
% [ecs|msor|sms]          Which school you are in.
%                         (msor option retained for reproducing old data)
% [bschonscomp|mcompsci]  Which degree you are doing
%                          You can also specify any other degree by name
%                          (see below)
% [font|image]            Use a font or an image for the VUW logo
%                          The font option will only work on ECS systems
%
\usepackage[image,ecs]{vuwproject} 

\supervisors{Lindsay Groves}
\otherdegree{Bachelor of Engineering with Honours in Software Engineering}

% Comment this out if you want the date printed.
\date{}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\todo}[1]{\huge{\underline{\textbf{\textcolor{RubineRed}{TODO}}: \textcolor{ForestGreen}{#1}}}\normalsize }

\begin{document}

% Make the page numbering roman, until after the contents, etc.
\frontmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
    \todo{abstract}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\mainmatter{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{1. Introduction}
% This should briefly outline the project and if necessary 
% reevaluate the original plan in light of what has been learned in the interim.  In
% particular, any significant deviations in the problem being addressed, or the solution
% being developed should be clearly highlighted and justified. (1 pages)
%% TODO: Also have the proposal as an appendix

% outline 
Whiley is a programming language that can be used for formal software
verification. One aspect of formal software verification is providing loop
invariants.
The primary goal of this project is to relieve some proof obligations from a
Whiley programmer by automatically providing some simple loop invariants.
Instead the loop invariants are generated by the Whiley Compiler itself.
This project does not attempt to generate loop invariants generally, as it is
known to be uncomputable, but generates invariants for specific common cases.

\subsection*{1.1 Motivation}

% Why
The purpose of this project is to make Whiley more usable in practise.
Loop invariants are a common pain point for users of formally verified
languages. Simple loop invariants are repetitive and become a chore to
always provide them. With this project some of this pain is alleviated.

\todo{changes since proposal}
% Changes since proposal

\subsection*{1.2 Solution}

% brief overview of solution
The solution this project provides to this problem is an extension to
the Whiley Compiler to generate simple loop invariants.
This includes the identification of simple loop invariants and being able
to generate a loop invariant from the source code of a Whiley program.
Since the Whiley Compiler is an open source project this project will be
hosted in a fork of compiler.

% 'simple'
The definition of a simple loop invariants for this project is an invariant that is
obvious at inspection that an invariant both exists and holds.
An example would be that while iterating through an array the index
will not go out of bounds of the array, such as figure~\ref{lst:whiley-ex-1}.
The purpose of having a strict definition of an simple invariant is to prevent
possible confusion when what looks to be unproven code is verified and to point
the scope of the project away from being too general, such as supporting
a rare scenarios such as indexing an array with a polynomial equation.
This leaves the more interesting invariants for the user to define.

\begin{figure}[h]
\begin{lstlisting}
    function indexOf (int[] items, int item) -> (int r)
    ensures r == |items| || items[r] == item:

    int i = 0

    while i < |items|
      where i >= 0 && i <= |items|:

        if items[i] == item:
            break
        i = i + 1

    return i
\end{lstlisting}
\caption{Verifiable Whiley code to find index of an item in an array}
\label{lst:whiley-ex-1}
\end{figure}

% loop patterns
Since the proposal it has become clear that simple loop invariants are
akin to design patterns for loops.
From studying a known loop pattern properties can be derived from it.
Such as figure~\ref{lst:whiley-ex-1} that has a common loop pattern of
iterating an array via an index variable.
From this pattern you know that that during the loop that the index will be
within bounds of the array.
This can be exploited by statically detecting the loop patterns and informing
the Whiley Compiler of these properties.

\section*{2. Background}
% This should discuss any existing solutions to the given problem,
% and may reference academic papers,  books and other sources as appropriate.   Care
% should be taken to identify key differences between these solutions,  and that being
% developed in the project. (3-4 pages)

%% TODO: ALL OF BACKGROUND
\todo{THE BACKGROUND!!!}
% intro

\subsection*{2.1 Formal Software Verification Languages}
%% Formal Software Verification
% goals of class of languages (could be covered in Whiley)

\subsubsection*{2.1.1 Whiley}
%% Whiley
% whiley design paper
\cite{whiley-origin} \cite{whiley-design}

\subsubsection*{2.1.1 Dafny}
% dafny - other formal languages
\cite{dafny-started}


\subsection*{2.3 Loop Invariants}
%% Loop invariants
% overview of loop invariants
% Theorem prover knows nothing about loop invariants - must give all
% * must hold at entry
% * must hold each iteration
% * must hold on exit
%
% * implies post-condition
% * implied by pre-condition

\subsubsection*{2.3.1 Classification of loop invariants}
% classification of loop invariants
%  * proves property
%  * hints to theorem prover
% example

\subsection*{2.4 Methods to generate loop invariants}
%% Methods to generate loop invariants
% generally generating loop invariants are impossible!

\subsubsection*{2.4.1 Static methods}
% infer dynamic

\subsubsection*{2.4.2 Dynamic methods}
% finding invariants via static analysis

\section*{3. Work Done}
% This should discuss what progress has been made on designing, implementing
%  and evaluating the artifact. Care must be taken to ensure that any discussion
% of technical points are clearly explained, with diagrams being used where appropriate.
% In many cases, the evaluation proper will not yet have begun. However, it is important
% to demonstrate that sufficient thought has been given to the evaluation.
% (2 pages)

The work done to date is multiple loop patterns have been implemented and
tested. The design of the extension to the Whiley compiler attempts follow
the rest of the design of the project.

\subsection*{3.1 Design}

Since the Whiley compiler has multiple passes over the abstract syntax tree
(AST)
the current design adds a new pass. The compiler passes runs checks of properties
of the program such as the definite assignment of variables and sound usage of
types. This project adds an additional pass that searches for loop patterns and
inserts generated code into the AST.
This has been called the Loop Invariant Generator (LIG) pass.
This is akin to a modern macro system operating directly onto the AST.

The overall design of the Loop Invariant Generator is to collect the required
information before a loop to be used to infer loop invariants.
This is using forward propagation to determine if the
information collected is safe to use. Once the LIG reaches a loop
it tests the loop to see if it fits a loop pattern. This has been
designed using the strategy pattern, where each loop pattern is encoded
into a single strategy and produces a single invariant.
The invariant is known to be valid since they are built up via language
semantics.

\subsection*{3.2 Implementation}
%% Implemented so far
% implemented algorithms for generating invariants
%  * entry value of a simple mutation and its sequence
%  * array length of a generated / copied array


From the work completed thus far there two loop patterns and their invariants
have been implemented. The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiley-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another. 
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.


\subsubsection*{3.2.1 Starting value invariant}
% entry value

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being 
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.

The definition of a simple mutation is restricted to an expression that only
includes addition and subtraction of constant values and the variable in question.
The mutation must be certain with each iteration so the variable must not be
modified inside branching statements such as \code{if} blocks or nested loops.
Since the mutation has to be simple it restricts them to linear monotonic
functions that is either strictly increasing or decreasing the variable with each iteration.
This is to keep the loop pattern simple and deterministic of knowing if the
mutation is increases or decreases the variable with each iteration.
An expression is checked if it is a simple mutation through static analysis of 
the AST.

\begin{figure}
    $$f(x) \text{is a linear function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
\label{math:simple-mutation}
\end{figure}

The increase or decreasing nature of the simple mutation it is determined by
executing the expression. An outline of the mathematical process is outlined 
in figure~\ref{math:simple-mutation}, the expression is denoted with $f(x)$. 
The equations show how the difference between applying the function twice and once on a base value is used to
determine if the function increases or decreases.
In the case that the expression is stationary the variable will not variate
between iterations and left alone.

\begin{figure}[h]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

With the identification of the variable with a simple mutation and knowing
if it decreases or increases each iteration an invariant can be made.
This is in the form of the variable on the left with either a less than or
equal to ($\leq$) or greater than or equal to ($\geq$) to the initial value on the
right.
In figure~\ref{lst:whiley-start} the variable \code{i} is clearly increasing
with each iteration due to line 7 and the inferred invariant, on line 5, is
obvious from the context.

\subsubsection*{3.2.2 Equal length arrays invariant}
% array length

From a common pattern of making a copy of arrays or generating another array
with an equal length an invariant can be inferred.
This loop pattern is found when applying a function that changes the type of
the element or the user does not wish to update the original array.
Figure~\ref{lst:whiley-length} shows a simple example of applying a function
\code{apply ()} to each element of an array.
Generally the user would also need to provide an invariant that both arrays
have the same length to prevent possible out-of-range errors or prove a
post-condition.

With this invariant it is detected that an array is declared with the same
length as another array.
This is achieved by inspecting the AST of the program
using forward propagation to find assignments to arrays.
Due to Whiley's copy semantics it is known that the assignment will result
in a clone of array and are distinct.
This can also be achieved by finding a use of the array
generator syntax, see line 4 of figure~\ref{lst:whiley-length}.

The arrays that are shown to be equal in length to another array are
check to ensure the array size does not change.
This is achieved by checking that there is no assignments to either
of the two arrays involved either before entering the loop or
anyway inside the loop.
If there was an assignment it is no longer a simple to infer if
the arrays are equal size and an invariant is not generated.
However, an assignment to an element of the array is passable since it
is known that it won't change the array size just the contents.

\begin{figure}[h]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    float[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        copy[i] = apply(items[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

From this information an invariant is known and can be generated.
Given the source array and the array of known equal length the
invariant of the lengths are equal.
See figure~\ref{lst:whiley-length} line 5 for the invariant generated
from the example code.

\subsection*{3.3 Evaluation}
%% Evaluation
% measurable deduction of proof obligations
% # of total loops effected

The evaluation of this project is to measure reduction of required loop
invariants. 
To measure the reduction a sizable code base that is also formally verifiable
is required to test against.
Currently the largest known code is the Whiley Compiler test suite.
Thus the evaluation is removing loop invariants from the test suite and
ensuring they are still formally verified.
So far this has been a success with a majority of loops have been simplified.

\section*{4. Future Plan}
% This should highlight the main components which remain to be done,
% and provide a proposed time-line in which this will happen. In putting together a time
% line, students must take into account upcoming examinations, coursework deadlines
% and other disruptions.
% (1 pages)

There are a range of improvements and additions that could be completed in
the time remaining of this project.
There could be improvements to the quality of the implementation with
the addition of more tests and documentation.
There could be additions of support for more loop patterns or tooling 
to let the user control which loop patterns are used.
Some of these are more stretch goals if there is time and 
others are more immediate concerns.

\subsection*{4.1 To be done}
% identify common loop patterns to  study & codify
% found a few 
%   * map pattern - loops through array applying function to each element
%   * for all - simple loop to see if all elements satisfies a condition
%   * for some - simple loop until an element satisfies a condition

The immediate goals for the project is to implement some additional loop
patterns. Some loop patterns have been identified but not yet
fully specified to a point that a loop pattern can be implemented.
These are:
\begin{itemize}
    \item Ending value of a loop, in the same vain of thought as the Starting
        Value invariant but attempting to detect the maximum value of the loop.
        This would be common when iterating arrays and the loop condition does
        not imply the maximum.
    \item Applying a function to every element in an array, such as a
        functional `map' and provide an invariant for the values.
        This would likely require the use of universal quantifiers
        and a copy of the original array in the invariant.
    \item Checking if all elements in an array meet a condition, such as 
        a `for all' universal quantifier, as well as a `for some' universal
        quantifier.
        This would require universal quantifiers in the invariant.
\end{itemize}

The project has a set of key dates over the next few months.
These have been outlined in figure~\ref{list:timeline}.

\begin{figure}[h]
    \begin{itemize}
        \item Draft Report (15th of September)
        \item Project Snapshot (29th of September) 
        \item Final Report (22nd of October)
        \item Presentation (17th of November)
    \end{itemize}
    \caption{Revised project timeline}\label{list:timeline}
\end{figure}

\subsection*{4.2 Stretch goals or future work}

Some stretch goals have been identified for this project that could
be completed if enough time or be ideas for future projects.
These include adding user controls over this extension in the
form of compiler flags, or detecting the duplication of an invariant,
or a functional fold notation for proofs.

% stretch: User controls
\subsubsection*{4.2.1 User Controls}
From a usability standpoint it would be a great addition to expose
some configuration of the loop invariant generators to the user.
This would most likely come in the form of compiler flags or even
a configuration file. The GNU compilers and their handling of
extension flags would be a good model to follow.

% stretch: Proof duplication detection
\subsubsection*{4.2.2 Invariant duplication detection}
With the addition of generated invariants there now may be 
duplicates of invariants. A possible solution to resolve this would 
be to warn the user if there is a detected duplication and
inform them how it was duplicated.
The duplication could be detected by syntactic or logical equivalence.
With this information the user can be informed with a warning message.
This feature would help the user to understand when the loop invariant
generators can be used.

% stretch: sum notation for Whiley
\subsubsection*{4.2.3 Fold notation for Whiley}
From my research into trying to prove the fundamental functional functions of
map, fold and for-all and for-some Whiley is missing the notation to prove
these ergonomically. The main pain point comes from trying to code a fold-like
function that require a changing state between each iteration. Currently this
can be achieved by using recursive function calls in proofs but this seems to
be a stop-gap solution. A possible solution to this problem is the 
introduction of a fold syntax such as `for some' or `for all' syntax that
already exists in Whiley. The requirements for the fold syntax would require
an initial state, a combination expression that evaluates to the next state
and a variable for the current state.
The largest issue with this suggestion is in how to encode this new structure
so the Whiley theorem prove can understand and prove it.

\section*{5. Request for Feedback}
% This should  highlight  any  difficulties  currently  faced,  and
% make specific requests for guidance from the examination committee.  For example,
% a student  may  be  unsure  how  best  to  evaluate  their  artifact,  and  would  appreciate
% suggestions for alternative methods.
% (1 pages)

%% Difficulties
% Additional ways to evaluate success

A current difficulty with the project is that I am unsure that the current
evaluation criteria is sufficient.
This is due to the only evidence the current criteria provides is a change set
of removed lines and passing cases. I would appreciate some guidance on
improving this or possible alternatives.

%% Help
% Suggested invariant patterns
% Additional ways to evaluate success


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\backmatter{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\bibliographystyle{ieeetr}
\bibliographystyle{acm}
\bibliography{report}

\appendix
% \includepdf[pages={1,3-5,7}]{../proposal/proj_proposal.pdf}

\end{document}

