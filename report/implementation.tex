\chapter{Implementation}\label{C:impl}
\comment{
The aim here is to explain the technical aspects of the project.
The challenge is to ensure the text is clear and understandable.
This is not easy, as ideas and concepts involved are often complex in nature.
Nevertheless, if an examiners cannot understand how the implementation works,
he/she cannot award marks for it.
If this happens, the student is fault for poor communication. \\

Remember: \\
nothing is so complicated that it cannot be clearly explained.
Classic pitfalls include: \\
    * long convoluted sentences, \\
    * use of long words, \\
    * too much time spent discussing irrelevant details, \\
    * poor organisation of sections, subsections and paragraphs, \\
    * and too few diagrams or examples.
}

\todo{re-do start of this}
The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiley-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another.
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.

\section{Starting Value Invariant}
\comment{
finds entry value \\
creates invariants from composing things \\
has the loop pattern of \\
int $i$ = $X$ \\
while $C$: \\
    $P_1$ \\
    $i = i (+|-) N$ \\
    $P_2$
}

\ref{s:sequence-dir} \ref{s:simple-mut} \ref{s:loop-context}

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.
The loop invariant inferred is a bounding invariant.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

With the identification of the variable with a simple mutation and knowing
if it decreases or increases each iteration an invariant can be made.
This is in the form of the variable on the left with either a less than or
equal to ($\leq$) or greater than or equal to ($\geq$) to the initial value on the
right.
In figure~\ref{lst:whiley-start} the variable \code{i} is clearly increasing
with each iteration due to line 7 and the inferred invariant, on line 5, is
obvious from the context.

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}

\section{Equal Length of Copied Arrays Invariant}
% array length
\comment{
    * finds associated arrays \\
    * checks to make sure source is not modified \\
    * asserts their length is the same \\

pattern: \\

$x = ( a | [X;|a|] )$ \\
while C: \\
    $P$ - not includes $x = X$, $a = Y$\\
}

\todo{remove techniques to design}

From a common pattern of making a copy of arrays or generating another array
with an equal length an invariant can be inferred.
This loop pattern is found when applying a function that changes the type of
the element or the user does not wish to update the original array.
Figure~\ref{lst:whiley-length} shows a simple example of applying a function
\code{apply ()} to each element of an array.
Generally the user would also need to provide an invariant that both arrays
have the same length to prevent possible out-of-range errors or prove a
post-condition.
The loop invariant inferred is a bounding invariant.

\todo{ref to design instead of assuming it is here}


With this invariant it is detected that an array is declared with the same
length as another array.
This is achieved by inspecting the AST of the program
using forward propagation to find assignments to arrays.
Due to Whiley's copy semantics it is known that the assignment will result
in a clone of array and are distinct \cite{whiley-origin} \cite{whiley-arrays}.
This can also be achieved by finding a use of the array
generator syntax, see line 4 of figure~\ref{lst:whiley-length}.

The arrays that are shown to be equal in length to another array are
check to ensure the array size does not change.
This is achieved by checking that there is no assignments to either
of the two arrays involved either before entering the loop or
anyway inside the loop.
If there was an assignment it is no longer a simple to infer if
the arrays are equal size and an invariant is not generated.
However, an assignment to an element of the array is passable since it
is known that it won't change the array size just the contents.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    float[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        copy[i] = apply(items[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

From this information an invariant is known and can be generated.
Given the source array and the array of known equal length the
invariant of the lengths are equal.
See figure~\ref{lst:whiley-length} line 5 for the invariant generated
from the example code.

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}

\section{Loop Condition Ageing Invariant}

\comment{
Finds simple mutations \\
Figures out actually how much the value changes every iteration
(is slight change on finding sequence direction, just stricter) \\
checks to ensure that the variable is apart of the termination condition of the
loop \\
Allow mutations of +1 or -1 each iteration\\

pattern: \\

$i = N$ \\
while $C$ \\
    $P_1$ \\
    $i = i (+|-) (1|-1)$ \\
    $P_2$ \\
}

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}

\section{Iterative Array Assignment Invariant}

\comment{
Finds arrays that are being set \\
Ensures the assignments are not self-dependent \\
Identifies the index variable and is simple mutations \\
Ensure index start of mutation on array, like starting bound \\
figures out sequence direction of index, ascending or descending the array \\
use index as the upper or lower bound \\
determines range of the mutation \\

pattern: \\

$i = N$ \\
$a = [ .. ]$ \\
while $C$: \\
    $a[i] = f(i)$ \\
    $i = i (+|-) (1|-1)$ \\

creates $all { \_i in C .. i | a[\_i] == f(\_i) }$
}

\subsection{Loop Pattern}

\subsubsection{Examples}
\subsubsection{Context}
\subsubsection{Problem}
\subsubsection{Forces}
\subsubsection{Solution}
\subsubsection{Resulting Context}

\subsection{Formal Definition}

\subsection{Limitations}
