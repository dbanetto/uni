\chapter{Design}\label{C:design}
\comment{
The aim here is to identify the key trade-offs in any design work you have undertaken.
When solving a complex problem, there are normally many different
approaches one can take — each with its own advantages and disadvantages.
It is expected that students will have initially considered a range of different solutions,
and will then have narrowed these down. The reasons why a particular approach was
discounted should be documented here.


Remember:
Appropriate design notation (e.g. UML diagrams) can be very helpful in conveying different aspects of a design.
It is vital that your design not be carried out in a vacuum.
Your design should be motivated very clearly by your goals and specifications.
Make sure that it is clear why you took the decisions that you did.
Do not give the impression that you settled on a design because it “felt right”
or that you tinkered around until you found something that worked.

Should cover: \\
 * techniques of loop invariant generation, \\
 * problem analysis \\
 * express the requirements of the solution \\
}

% intro to problem, what is the design space for this issue
%

\fixme{Update to include techniques are here, architectures in impl}

This chapter will discuss the requirements and considerations taken to design the implementation
of this project.
These considerations are derived by the project requirements
and guided by improving or retaining the same level of
usability of the Whiley Compiler for a Whiley developer and a maintainer of the
compiler fixing or updating the modified compiler.
It will also discuss the internal design decisions of
where to place the loop invariants generators in the
current architecture of the Whiley Compiler.
This includes where the generated loop invariants are found and
how they are inserted into the program.
The final design decision discussed is how the multiple generators are managed.

\section{Requirements}
\comment{
    should cover the functional and non-functional requirements
}

The requirements for this project are derived from the original project
outline (see Appendix~\ref{A:proj-outline}).
The base requirements of each loop invariant generator is to be grounded
in practicality of the invariant not the generality of its use cases.
This is to say that it is not worth expanding a loop invariant
generator to cover cases that are unlikely to actually occur for generality
sake.

The other major requirement is that the Whiley compiler will be improved
with the addition of loop invariant generators.
This implicitly includes maintaining the current level of quality or
improving the experience with this extension.

Some parts of the original project outline fell out of scope of this project.
This included the students of SWEN224 would be used to evaluate this solution.
The decision to drop this requirement was in favour of focusing on implementing
many loop invariant generator rather than making a split effort of implementing
less generators so that proper user testing can be completed.
It was also found to be impracticable as the course layout of SWEN224 saw the
Whiley section taught in the last half of the semester with loop invariant in
particular taught in the final weeks making properly timed user studies
impracticable.

\todo{expand on the problem}

\todo{make requirements eat the considerations section}

Below is a list of design considerations that were identified to keep to ensure
that these requirements are met.
Each of these considerations either focus the development of the loop
generators or to force quality control on how they interact with the rest of the
compiler.

\begin{itemize}
    \item{Backward compatibility with non-loop invariant generated code.}
    \item{Not to hamper the ability to inspect and debug generated code.}
    \item{Avoid impacting runtime with generating code.}
    \item{Ensure the user can control the feature.}
    \item{Not all of the generated loop invariants will be useful.}
\end{itemize}

\subsection{Backwards Compatibility}
\comment{
pre-existing code should not fail because of the generated invariants
code that compiles without the flag should still compile with the flag
restricts loop invariants to be precise  and strict to avoid "wrong"
}

To maintain the quality of compiler code that previously would verify without 
generated loop invariants should still verify with them.
This is important for any existing codebases in Whiley to have choice of
moving to use the generated loop invariants without needing to resolving new
errors.
If and when this occurs it is considered a bug and evidence that the implementation 
of a generated loop invariant is unsound and should be reviewed.

\subsection{Inspection and Debugging}
\comment{
Allow debugging / reviewing  of generated code
achieved by emitting compiler messages about what, where and why they are
generated
}

The ability to be able to inspect or debug the generated code is an important feature to
ensure quality of extension to Whiley.
This is in the form of compiler message describing what, where and why
the loop invariants were generated or by writing the modified program back
to disk as source code.
This allows a user to be able to inspect and review the generated loop invariants for
debugging of their code or in the process of debugging a generator.
The compromise made by this feature is that it requires coupling to other
subsystems to report back these changes.
For example to emit a compiler message appropriately it would need
to couple with the logging sub-system to enforce common log modes such as
\code{DEBUG} and \code{VERBOSE}.

\subsection{Impacting Runtime}\label{s:design-create-var}
\comment{
Whiley does not have the notion of ghost variables \\
* possible name collisions \\
* This is to be avoided \\

Does force the programmer to make ghost variables or make copies
that make sense if they were making the invariants themselves vs generated
}

To ensure the quality of generated code there should be no impact on the
runtime of the program.
The most problematic situation is attempting to refer to previous values of
a variable during or before the loop.
Whiley does not have a notion of ghost variables, variables only used for
specifications, this forces the use of additional local variables instead~\cite{whiley-origin}.
Figure~\ref{lst:vars} shows a common code example when the additional local
variables are used, in this case \code{items} variable is used to compare
against the previous value.
This forces a loop generator to either create their own ghost variables or
attempt to identify another local variable in the program that will act as the
same.
To generate the local variable the type of the copied variable is needed to be
known to mimic and a new statement directly before the loop is needed to be
added.
For example figure~\ref{lst:vars} would replace the \code{modified} variable
with \code{items} and the generated code will have an assignment just before
the while loop.
The issue of creating local variables is that it could add a runtime cost by
adding an additional copy of a potentially large data structure
and holding it in memory without being used.
The alternative to this is to restrict the loop invariant generators to check
for other variables that can work as pseudo-ghost variables.
This pattern is common in Whiley code as the lack of ghost variables require
the style of code in figure~\ref{lst:vars} to verify.
This resolves the issue of hidden local variables from the programmer
and gives them control over how they are handled.
The trade-off of not having a hidden runtime cost with restricted generators
is the most beneficial for the end-user as existing code will also benefit
and for more complex invariants the ghost variables are still required.

\begin{figure}[ht]
\begin{lstlisting}
function add_one(int[] items) -> int[]:
    i = 0
    modified = items
    //
    while i < |items|
        where all { k in 0..i | modified[i] == items[i] + 1 }
        where |modified| == |items|:
        modified = items[i] + 1
        i = i + 1
    //
    return modified
\end{lstlisting}
\caption{Example of Whiley program with \code{modified}.}
\label{lst:vars}
\end{figure}

\subsection{Usability}
\comment{
COMPILER FLAGS \\
How easy it is to control the functionality  \\
Error messages \\
No goal on time impact \\
Choice to not repeat compilation and verification
}

The command line interface and the WhileyWeb IDE are the only user interfaces
of the Whiley Compiler.
The modification of the WhileyWeb IDE was out of scope of this project as it
would only be beneficial if user studies were conducted.
Thus the only user interface that the usability needs to be maintained or
improved is the command line interface.
This includes how users can control the loop invariants generators and what
compiler feedback is required.
This is handled by exposing control of the loop invariants generators via
a compiler flag.
This is inline with how other optional features are handled in Whiley and
other standard compilers such as the GNU C compiler.

\subsection{Essential Invariants}\label{s:essential-inv}
\comment{
It is known that all invariants generated will not be useful to proving the post-condition
(due to P-C has no input generated inv) \\

It is OK to have the minimal set of invariants
to test if it is essential requires repetitive verifications, infringes on
impact on compile time.
}

To provide some base quality of loop invariant generators that generated invariants 
can be redundant.
This means that it is acceptable that a generated invariant is not
checked that it is redundant for the verification of the loop or the function
as whole.
If the generated loop invariant were checked if they were redundant
they would need to determine what is essential either by greatly increasing
the complexity of the generators by inferring if there is another invariant
that is a stronger or weaker condition than itself.
Another method would be to attempting to find the
minimal set of invariants by testing combinations of invariants.
The trade-off of this decision is that at the cost of having some redundant
invariants that the complexity of code and time generating loop invariants is
greatly reduced.

\section{Targeted loop invariants}

Though each loop had many individualised loop invariants some invariant held a
common pattern across the loops.
From these commonly recurring invariants four of them were identified and
studied why they were applicable.
This section outlines these invariants, gives examples of where they apply and
describes the commonly observed loop structure where they occur.
with a loop design pattern \cite{pattern-lang}.

\fixme{not sure if the loop pattern stuff actually works out now}
\fixme{would loop invariant patterns be more applicable?}

\subsection{Starting bound}

The starting bound invariant is a common bounding invariant for a counting
variable in a loop.
The use of counting variables are common in Whiley due to a lack of 
general \code{for} loops that have self-contained counting variables
that are seen in languages such as Java.
The most common use case of this loop invariant is enforcing that 
a variable used to index an array is greater than 0 as shown in
figures~\ref{lst:starting-bound-sum} and \ref{lst:starting-bound-contains}.
It is obvious from inspection that the value of \code{i} is 0 at entry
of the loop and that it will increase with every iteration from the code before
and inside the loop.
This is required since the Whiley theorem prover cannot generally 
determine the value of the variable and instead relies on the programmer
providing the range, be it partially or completely specified.

\subsubsection{Loop Pattern}

The commonly thread between each instance of a starting bound invariant
is the structure before and in the loop.
Before the loop it is observed that initial value of the counting
variable is initialized or set to constant a constant value.
This is either the lower or upper bound of the range of the loop.
Inside the loop the body ensures that the counting variable is within
the range.
This is generally be achieved by incrementing or decrementing the variable
to the other boundary of the array than it started on, from lower to upper or
upper to lower bound respectfully.

\paragraph{Examples}

Below are three valid Whiley programs that contain a starting bound
invariant.
Each of these examples are operating on lists since they are verifiable
examples in the current version of Whiley.
This includes a simple iterations that use counters. Though not all
examples require the starting bound invariants to verify they still hold.


\begin{figure}[ht]
\begin{lstlisting}
int counter = I
...
while C
    where f(counter) <> I:
    ... 
    counter = f(counter)
    ...
\end{lstlisting}
    \caption{Example of a starting bound invariant for Fibonacci sequence (unverified).}
\label{lst:starting-bound-gen}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function fib(int iter) -> (int r)
requires iter >= 0
requires iter == 0 ==> r == 1
requires iter == 1 ==> r == 1
ensures  iter > 1  ==> r == fib(iter - 1) + fib(iter - 1):
    // declarations omitted
    i, a, b = iter, 1, 0
    while i >= 0
        where i <= iter && a >= 1 && b >= 0 // starting bounds
        ... // omitted
        int c = a
        a = a + c
        b = c
        i = i + 1
    //
    return a
\end{lstlisting}
    \caption{Example of a starting bound invariant for Fibonacci sequence (unverified).}
\label{lst:starting-bound-fib}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function sum(int[] items) -> (int r)
requires all { i in 0..|items| | items[i] >= 0 }:
    int i = 0
    int sum = 0
    while i < |items|
    where sum >= 0
    where i >= 0: // starting bound
        sum = sum + items[i]
        i = i + 1
    //
    return sum
\end{lstlisting}
\caption{Example of a starting bound invariant.}
\label{lst:starting-bound-sum}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}
function contains(int[] items, int item) -> (bool r)
ensures  r ==> some { i in 0..|items| | items[i] == item }
ensures !r ==> all  { i in 0..|items| | items[i] != item }:
    int i = 0
    while i < |items|
    where i >= 0 // starting bound
    where all { j in 0..i | items[j] != item }:
        if items[i] == item:
            return true
        i = i + 1
    //
    return false
\end{lstlisting}
\caption{Example of a starting bound invariant.}
\label{lst:starting-bound-contains}
\end{figure}

\fixme{ran out of pages? put this in appendix!}

\paragraph{Context} 

The context of the pattern is to solve the issue that the loop 
body want to keep track of where it is in the loop.
This could be to count the number of iterations or keeping track
of what element is to be processed in the next iteration.

\paragraph{Problem}

This loop pattern seeks to solve the problem of 

\paragraph{Forces}

\paragraph{Solution}

\paragraph{Resulting Context}

\todo{bunch of examples}

\subsection{Equal array length}

\todo{bunch of examples}

\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | items[i] + delta == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0 // starting bound
    where |mod| == |items| // equal array length
    where all { j in 0..i | items[j] + delta == mod[j] }:
        mod[i] = items[i] + delta
        i = i + 1
    //
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}


\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | items[i] + delta == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0 // starting bound
    where |mod| == |items| // equal array length
    where all { j in 0..i | items[j] + delta == mod[j] }:
        mod[i] = items[i] + delta
        i = i + 1
    //
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}

\subsection{Upper bound}

\todo{bunch of examples}


\begin{figure}[ht]
\begin{lstlisting}
function len(int[] items) -> (int r)
ensures r == |items|:
    int i = 0
    while i < |items|
    where i <= |items| // upper bound
    where i >= 0:
        i = i + 1
    return i
\end{lstlisting}
\caption{Example of an upper bound invariant.}
\label{lst:starting-bound-rev}
\end{figure}
 

\subsection{Array iterative assignment}

\todo{bunch of examples}

\begin{figure}[ht]
\begin{lstlisting}
function add(int[] items, int delta) -> (int[] r)
ensures |r| == |items|
ensures all { i in 0..|r| | (items[i] + delta) == r[i] }:
    int i = 0
    int[] mod = items
    while i < |items|
    where i >= 0
    where |items| == |mod|
    // iterative assignment
    where all { j in 0..i | mod[j] == (items[j] + delta) }:
        mod[i] = items[i] + delta
        i = i + 1
    return mod
\end{lstlisting}
\caption{Example of equal array length invariant.}
\label{lst:starting-bound-rev}
\end{figure}

\section{Techniques used to infer properties of a loop}
\comment{
Cover the individual techniques that were used in each generator \\
 - discovering loop context \\
 - determining if a variable has a simple mutation \\
 - determining if a sequence is increasing or decreasing  \\
 - decomposing loop conditions \\
 - identify usage of variables in the loop \\
 - associating a copied array back to its source \\
 - checking for self dependencies \\
}

Each loop invariant is the composition multiple techniques to generate their
invariants. This section will provide discuss the techniques, what they
accomplish and where their limitations lay.
The techniques covered are:

\begin{itemize}
    \item{Loop Context}
    \item{Determining a simple mutation}
    % \item{Decomposing Loop conditions and Invariants}
    \item{Associate copied arrays to source}
\end{itemize}

\subsection{Loop Context}\label{s:loop-context}
\comment{
Write about the pre-loop stuff \\
 * how it collects data \\
 * what data it collects \\
 * why it collects \\
 * how it decides what to collect \\
 * how it differ between variables and parameters
}

\fixme{Break up and expand on this}

The loop context provides all of the techniques an understanding of the
variables before the loop.
This is used to replace the instance of the variable with its assigned value
before the loop.
This base information provides the values of local variables and parameters of
the function and tracks their values through the statements before the loop.
On a branching point in the program the context of each path is collected
separately then the intersection is taken with respect to the
parent context when the branches join.
The intersection is used so only variables that were only defined in the
branch does not leak into the rest of the context and variables defined outside
of the branch and mutated in it are updated.
In the case that an existing variable is mutated in a branch the value becomes
undetermined as it is unknown if the branch will be taken.
Figure~\ref{lst:loop-context} shows an illustration of information captured as
the context is collected though the statements before the while loop.
In particular the variable \code{limit} shows how branches are handled
and that it becomes indeterminable at the loop due to being mutated in the if
branch.

\begin{figure}[ht]
\begin{lstlisting}
function f(int count): // C = { count: <parameter }
    int[] items = [0; count] // C + { items -> [0; count] }

    int limit = 0 // C +  { limit -> 0 } 

    if g(items): // branch: C -> C`
        int f = 1 // C' + { f -> 1 }
        limit = h(items) // C' + { limit -> h(items) }
    // C` intersection C => C + { limit -> ?? }

    int i = 0 // C + { i -> 0 }

    // Final Loop context
    // C is { count -> <parameter>, items -> [0;count],
    //   limit -> ??, i -> 0 }
    while i <= limit:
        items[i] = i
        i = i + 1
\end{lstlisting}
\caption{Example of the information gathered by the loop context}
\label{lst:loop-context}
\end{figure}

\subsection{Determining a simple mutation}\label{s:simple-mut}

\fixme{Break up and expand on this}

A simple mutation is an expression that only includes addition or subtraction
of a known variable or constant.
This is to test that the expression is a monotonic expression \cite{tanton2005encyclopedia}.
Operations such as multiplication, division and function calls are disallowed
because the monotonic property of these operations are dependent on their
runtime values.
For example a multiplication between a constant and a variable,
the result of the expression may change from being an increasing expression
to decreasing after some unknown point, such as a polynomial equation.

The current design only allows a single variable to be in a simple mutation
expression.
That variable must also be the variable that is being mutated as well.
For example in figure~\ref{lst:simple-mutations} the assignment of \code{i} on
line 3 is simple since it refers to itself variable.
However, the assignment of \code{f} on line 6 is not simple as
it refers to a variable that is not \code{f}.
This limitation is due to a only needing to 
support single variable mutations for the loop invariants
that depended on this mechanism.

\begin{figure}[ht]
\begin{lstlisting}
int i = 0
int f = 0
i = i + 1 // simple
i = i + 1 - 10 + 1 + 1000 // simple
f = g(f)  // not simple
f = i + 1 // not simple
f = f * f // not simple
\end{lstlisting}
\caption{Example simple mutations}
\label{lst:simple-mutations}
\end{figure}

\subsection{Determining if a value is increasing or decreasing}\label{s:sequence-dir}

\fixme{Break up and expand on this}

From a simple mutation inside a loop it can be determined if the value is
increasing or decreasing with each iteration.
To achieve this the symbolic executable property of a simple mutation is
exploited to simulate two iterations worth of mutations.
The known variable in the mutation is set to an initial value of zero for
the first iteration and uses the result for the second.
Since the simple mutation is a linear monotonic function it is known that
the difference between each iteration will be constant.
From the result of difference between the first and second iteration the
value can be observed to increase for all iterations if it is positive or
decrease if negative. If there is no difference between the iterations then
it is considered stationary and is considered an error state.
This process is outlined in figure~\ref{math:simple-mutation}.

\begin{figure}
    $$\text{Given that } f(x) \text{ is a linear monotonic function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
    \caption{Outline of determining if a function increases or decreases with
    each application}
\label{math:simple-mutation}
\end{figure}

%\subsection{Decomposing Loop conditions and Invariants}\label{s:cond-decompose}
%\comment{
%    Whiley semantics means all where clauses are conjunctively joined, \\
%    A loop condition that is conjunctively joined can be broken into
%    segments
%}

\subsection{Associate length of copied arrays to source}\label{s:copied-array}
\comment{ was a array initialised with a copy from an array type or use a
generator }

The length of a new array can determine by associating the length to a source
array.
This relies on how the new array is created, for example if the array is
generated using an array generator or from copying another array it can be.
However, if the array is generated by a function it is more difficult to
determine and was out-of-scope.
When using an array generator the length of the array can be determined by
evaluating the count of the generator.
Figure~\ref{lst:simple-mutations} has an example of this for the initialisation
of \code{a}, where the length of the array is associated with the value 10.
In the case of an array copy the array size can be determined by taking the
size of the source array as they will be equal.
This is shown in figure~\ref{lst:simple-mutations} when initialising \code{b}
and \fixme{should associations be transitive? or transitive to a list of values}

This technique is used to associate ghost arrays used to assist in writing
loop invariants.

\begin{figure}[ht]
\begin{lstlisting}
int[] a = [0; 10] { |a| -> 10 }
int[] b = a { |b| -> 10, |a| -> |b| }
int[] c = f() { c -> ?? }

a = f() { |a| -> ?? }

// final association: { |b| -> 10, |a| -> ??, |c| -> ?? }
\end{lstlisting}
\caption{Examples of associated array lengths}
\label{lst:simple-mutations}
\end{figure}
