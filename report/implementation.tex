\chapter{Implementation}\label{C:impl}
% The aim here is to explain the technical aspects of the project.
% The challenge is to ensure the text is clear and understandable.
% This is not easy, as ideas and concepts involved are often complex in nature.
% Nevertheless, if an examiners cannot understand how the implementation works,
% he/she cannot award marks for it.
% If this happens, the student is fault for poor communication.
%
% Remember:
% nothing is so complicated that it cannot be clearly explained.
% Classic pitfalls include:
%     * long convoluted sentences,
%     * use of long words,
%     * too much time spent discussing irrelevant details,
%     * poor organisation of sections, subsections and paragraphs,
%     * and too few diagrams or examples.


% TODO: re-do start of this
The first loop pattern is incrementing a variable
each iteration of the loop, most commonly used for indexes into an array to
iterate through it. See figure~\ref{lst:whiley-start} for a simple example.
The second loop pattern is making a copy of an array or creating an array with
the same length as another.
This is used generally when transforming every element in array into a separate
variable. See figure~\ref{lst:whiley-length} for a simple example.

\section{Starting value invariant}
% entry value
% TODO: Update to include lattice

From loop pattern of incrementing a variable each iteration of the loop
a invariant of the starting value can be inferred.
This invariant requires to know which variable is being
mutated in a simple manner each iteration,
the value of the variable at entry of the loop and if the mutation is an
increasing or decreasing sequence.
From this information an invariant be generated that encapsulates that the
variable will be increasing or decreasing from the initial value.
An example of the invariant generated is on line 5 of
figure~\ref{lst:whiley-start}.
The loop invariant inferred is a bounding invariant.

The definition of a simple mutation is restricted to an expression that only
includes addition and subtraction of constant values and the variable in question.
The mutation must be certain with each iteration so the variable must not be
modified inside branching statements such as \code{if} blocks or nested loops.
Since the mutation has to be simple it restricts them to linear monotonic
functions that is either strictly increasing or decreasing the variable with each iteration.
This is to keep the loop pattern simple and deterministic of knowing if the
mutation is increases or decreases the variable with each iteration.
An expression is checked if it is a simple mutation through static analysis of
the AST.

\begin{figure}
    $$f(x) \text{is a linear function}$$

    $$diff = f(f(0)) - f(0)$$

    \[
        diff \begin{cases}
            = 0 \quad f(x) \text{ is stationary}\\
            > 0 \quad f(x) \text{ is increasing}\\
            < 0 \quad f(x) \text{ is decreasing}\\
        \end{cases}
    \]
\label{math:simple-mutation}
\end{figure}

The increase or decreasing nature of the simple mutation it is determined by
executing the expression. An outline of the mathematical process is outlined
in figure~\ref{math:simple-mutation}, the expression is denoted with $f(x)$.
The equations show how the difference between applying the function twice and once on a base value is used to
determine if the function increases or decreases.
In the case that the expression is stationary the variable will not variate
between iterations and left alone.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int i = 0

    while i < |items|:
        // 'where i >= 0' is inferred
        apply(items[i])
        i = i + 1
    ...
\end{lstlisting}
\caption{Simple example of inferring starting bound of index}
\label{lst:whiley-start}
\end{figure}

With the identification of the variable with a simple mutation and knowing
if it decreases or increases each iteration an invariant can be made.
This is in the form of the variable on the left with either a less than or
equal to ($\leq$) or greater than or equal to ($\geq$) to the initial value on the
right.
In figure~\ref{lst:whiley-start} the variable \code{i} is clearly increasing
with each iteration due to line 7 and the inferred invariant, on line 5, is
obvious from the context.

\section{Equal length arrays invariant}
% array length

From a common pattern of making a copy of arrays or generating another array
with an equal length an invariant can be inferred.
This loop pattern is found when applying a function that changes the type of
the element or the user does not wish to update the original array.
Figure~\ref{lst:whiley-length} shows a simple example of applying a function
\code{apply ()} to each element of an array.
Generally the user would also need to provide an invariant that both arrays
have the same length to prevent possible out-of-range errors or prove a
post-condition.
The loop invariant inferred is a bounding invariant.

With this invariant it is detected that an array is declared with the same
length as another array.
This is achieved by inspecting the AST of the program
using forward propagation to find assignments to arrays.
Due to Whiley's copy semantics it is known that the assignment will result
in a clone of array and are distinct \cite{whiley-origin} \cite{whiley-arrays}.
This can also be achieved by finding a use of the array
generator syntax, see line 4 of figure~\ref{lst:whiley-length}.

The arrays that are shown to be equal in length to another array are
check to ensure the array size does not change.
This is achieved by checking that there is no assignments to either
of the two arrays involved either before entering the loop or
anyway inside the loop.
If there was an assignment it is no longer a simple to infer if
the arrays are equal size and an invariant is not generated.
However, an assignment to an element of the array is passable since it
is known that it won't change the array size just the contents.

\begin{figure}[ht]
\begin{lstlisting}
    ...
    int[] copy = items
    // or
    float[] copy = [0;|items|]
    while i < |items|:
        // 'where |copy| == |items|' is inferred
        copy[i] = apply(items[i])
    ...
\end{lstlisting}
\caption{Simple example of inferring array lengths are equal}
\label{lst:whiley-length}
\end{figure}

From this information an invariant is known and can be generated.
Given the source array and the array of known equal length the
invariant of the lengths are equal.
See figure~\ref{lst:whiley-length} line 5 for the invariant generated
from the example code.

\section{Loop Condition Ageing Invariant}

\subsection{Formal Definition}
\subsection{Example}
\subsection{Limitations}

\section{Array quantified assignment Invariant}

\subsection{Formal Definition}

\subsection{Example}

\subsection{Limitations}
